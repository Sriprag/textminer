388

IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 20, NO. 1, JANUARY 2016

Exploiting Semantic Web Technologies to Develop
OWL-Based Clinical Practice Guideline
Execution Engines
Borna Jafarpour, Samina Raza Abidi, and Syed Sibte Raza Abidi

Abstract—Computerizing paper-based CPG and then executing
them can provide evidence-informed decision support to physicians at the point of care. Semantic web technologies especially web
ontology language (OWL) ontologies have been profusely used to
represent computerized CPG. Using semantic web reasoning capabilities to execute OWL-based computerized CPG unties them from
a specific custom-built CPG execution engine and increases their
shareability as any OWL reasoner and triple store can be utilized
for CPG execution. However, existing semantic web reasoningbased CPG execution engines suffer from lack of ability to execute
CPG with high levels of expressivity, high cognitive load of computerization of paper-based CPG and updating their computerized
versions. In order to address these limitations, we have developed
three CPG execution engines based on OWL 1 DL, OWL 2 DL
and OWL 2 DL + semantic web rule language (SWRL). OWL 1
DL serves as the base execution engine capable of executing a wide
range of CPG constructs, however for executing highly complex
CPG the OWL 2 DL and OWL 2 DL + SWRL offer additional
executional capabilities. We evaluated the technical performance
and medical correctness of our execution engines using a range
of CPG. Technical evaluations show the efficiency of our CPG
execution engines in terms of CPU time and validity of the generated recommendation in comparison to existing CPG execution
engines. Medical evaluations by domain experts show the validity
of the CPG-mediated therapy plans in terms of relevance, safety,
and ordering for a wide range of patient scenarios.
Index Terms—Clinical guideline computerization, clinical guideline execution, clinical practice guidelines, OWL reasoning, semantic web, SWRL, web ontology language (OWL).

I. INTRODUCTION
LINICAL practice guidelines (CPG) aim to standardize
diagnostic and treatment procedures with the goal of reducing care costs and increasing quality and consistency of care
[1]. CPG stipulate a set of evidence-based principles providing
standardized recommendations about the best diagnostic and
therapeutic actions for disease-specific clinical situations. Despite the fact that CPG recommendation are intended to assist
health-care professionals, paper-based CPG are underutilized
due to several reasons such as lack of agreement with the CPG,
difficulty in following the recommendations because they do not

C

Manuscript received July 21, 2014; revised October 31, 2014; accepted December 7, 2014. Date of publication December 18, 2014; date of current version
December 31, 2015. This work was supported in part by NSERC, Canada,
under a Discovery Grant.
B. Jafarpour and S. S. R. Abidi are with the Faculty of Computer Science, Dalhousie University, Halifax, NS B3H 4R2, Canada (e-mail: jafarpour@dal.ca;
sraza@cs.dal.ca).
S. R. Abidi is with the Faculty of Medicine, Dalhousie University, Halifax,
NS B3H 4R2, Canada (e-mail: samina.abidi@dal.ca).
Digital Object Identifier 10.1109/JBHI.2014.2383840

provide patient specific advice, and increased cognitive burden
of decision making [2]. To operationalize CPG in clinical care
settings, there have been numerous efforts to develop clinical
decision support systems (CDSS) [3]–[15] that: 1) computerize
paper-based CPG using formal knowledge models and 2) execute the computerized CPG using specialized execution engines
to provide personalized and CPG-mediated therapy plans for
patients to assist healthcare professionals. A recent survey of
these frameworks is provided by Peleg [16].
The popularity of semantic web has led to various developments including several OWL syntaxes such as TURTLE syntax [17], API to access OWL ontologies [18], [19], ontology
visualization tools [20], OWL reasoners [18], [21], and query
languages such as SPARQL [22]. Semantic web-based CPG
computerization using OWL ontologies is quite prevalent [8]–
[15] due to shareability and machine processability offered by
abundance of tools and standards. OWL allows a standard-based
semantic description of CPG that can then be shared, integrated
and executed to achieve a range of CPG-mediated decision support services.
Execution of a computerized CPG is typically pursued by
two approaches: 1) graph traversal approach that uses an algorithm to traverse the modeled clinical workflow of the CPG in
conjunction with inputs from health-care professionals and patient information sourced from electronic medical records [3],
[4], [7], [14], [23], [24] and 2) reasoning-based approach where
the execution semantics of a CPG is modeled in a formal representation language (such as petri nets). The CPG execution
engine uses a general purpose reasoner to infer the next task to
be executed based on the clinical workflow of the CPG, current
executional states of CPG tasks and available patient data [5],
[6], [8]–[10], [25].
Reasoning-based CPG execution approach has the following
advantages compared to graph traversal approach: 1) increased
shareability of computerized CPG, 2) increased flexibility of
switching to different implementation technologies and 3) possibility of formal analysis of computational complexity and decidability of CPG execution. We discuss these advantages in
more details in Section II. Despite these advantages, we note
that semantic web reasoning is underutilized for execution of
OWL-based CPG except for a few cases [8]–[10]. Even these
frameworks suffer from limitations such as lack of ability to
execute CPG with high levels of expressivity.
In this paper, we explore the potential of OWL in reasoningbased CPG execution approach to execute OWL-based computerized CPG. We develop three CPG execution engines called

2168-2194 © 2014 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See http://www.ieee.org/publications standards/publications/rights/index.html for more information.

JAFARPOUR et al.: EXPLOITING SEMANTIC WEB TECHNOLOGIES TO DEVELOP OWL-BASED CLINICAL PRACTICE GUIDELINE

OWL 1 Description Logic (DL)-based CPG execution engine,
OWL 2 DL-based CPG execution engine and OWL 2 DL +
SWRL-based CPG execution engine with incremental executional capabilities and computational complexities. OWL 1 DL
serves as the base CPG execution engine capable of executing
a wide range of CPG constructs, however for executing highly
complex CPG functions (such as iterative tasks, mathematical
calculations) the OWL 2 DL and OWL 2 DL + SWRL offer
more advanced executional capabilities.
Our CPG execution engines offer benefits of the reasoningbased CPG execution approach and at the same time avoid
limitation of the existing semantic web reasoning-based CPG
execution engines [8]–[10]. In our study, we demonstrate the
potential of OWL reasoning, such that CPG represented using
OWL can be effectively executed in their native OWL environment. We used six nursing CPG, chronic heart failure (CHF)
and atrial fibrillation (AF) CPG for both technical and medical
evaluations.
II. RELATED STUDY
In this section, we present our review of the execution strategies utilized in CPG execution engines as reported in the literature. A similar survey has been reported by Isern and Moreno
[26]. However, this survey mostly discusses the internal components of the execution modules in CDSS rather than their CPG
execution strategy. Our review concludes that there are two main
strategies for CPG execution.
In the first execution strategy, referred as the graph traversalbased CPG execution approach, a state transition model is implemented in a programming language (such as Java) to simulate
the state transition of the CPG tasks, as they would be followed
in a paper-based CPG by healthcare professionals [3], [4], [7],
[14], [23], [24].
In the second strategy, referred as reasoning-based CPG execution approach, the CPG’s workflow execution semantics are
represented in a formal representation language (such as OWL),
and the CPG execution is achieved by reasoning over the execution semantics. Petri nets [6] and BMPN [25] are two examples
of languages with formal execution semantics that have been
utilized for CPG execution. Another example of this execution
approach is used in a PROforma execution engine called Tallis
[5]. This engine translates CPG modeled in red representation
language (R2 L) to RR2L (logic of R2 L) a language based on
predicate logic. Subsequently, a proprietary reasoner is used to
parse and execute these translated PROforma CPG. We have
noted that often since languages with formal execution semantics are too low level for direct CPG computerization, CPG are
computerized in a different language and then translated to these
languages.
Graph traversal-based and reasoning-based CPG execution
approaches are different in the following aspects: 1) Formal
Analysis: The reasoning approach defines execution semantics
in a formal knowledge representation language instead of a
customized graph traversal algorithm, thus providing an opportunity for formal analysis of the CPG execution engine’s computational complexity and decidability. 2) Performance: Graph

389

traversal algorithms offer higher performance as they only infer
the facts pertaining to CPG execution whilst general purpose
reasoner investigate trueness of all possible facts regardless of
their relevance to CPG execution. 3) Flexibility: Possibility of
using any reasoner of the used formal language to execute a
computerized CPG in the reasoning-based CPG execution engine increases the flexibility to choose different implementation
technologies. In case of using OWL to define the execution
semantics, the following difference can also be noted. 4) Shareability and Reusability: Since CPG and its execution semantics
are both represented in OWL, less number of tools and standards
are needed to share the computerized CPG in the reasoningbased CPG execution approach. Hence, they are easier to be
shared and reused.
Despite the advantages of reasoning-based CPG execution
approaches, it has not been utilized for execution of OWLbased CPG except for a few cases [8]–[10] that use SWRL
to define the execution semantics. Noted limitations of these
frameworks are: 1) Clinical workflow of a CPG and the execution semantics are intertwined in several SWRL rules. Thus,
execution semantics cannot be readily reused for execution of
other computerized CPG. 2) Lack of ability to represent and
execute complex workflow patterns (e.g., iterative tasks) due to
lack of explicit constructs in SWRL for this purpose.
III. PAPER-BASED CPG COMPUTERIZATION
CPG need to be computerized prior to executing. To computerize a CPG, we used the CPG ontology developed by Abidi
[27] as it builds on all the existing CPG ontologies available
to us [27]–[29] and introduces new constructs to computerize a
CPG, such as handling several concurrent diseases in comorbid
patients. CPG ontology [27] represents a range of clinical workflow constructs—i.e., sequential constraints, conditions, task hierarchy, splits, synchronizations, and iterative tasks. We briefly
discuss how this ontology has been extended in order to represent more complex condition satisfaction criteria and mathematical expressions needed for processing quantitative patient
data.
A. Complex Condition Satisfaction Criteria
CPG recommend conditional tasks such as prescribing a drug
if certain conditions are satisfied. In the CPG ontology [30], the
hasCondition property with the domain of Task and range of
Condition is used to assign conditions to tasks. The assumption in CPG ontology is that all conditions of a task need to
be satisfied in order to be executed, but this is an oversimplification of the CPG’s intent as there are more complex cases
where a conditional task should be executed when minimum,
maximum or exactly n of its conditions are satisfied. As an
example, task remove_foreign_bodies from management of ocular conditions nursing CPG [14] has three conditions and a
minimum two out of three conditions should be satisfied before this task can be executed. To account for the presence of
more complex condition satisfaction criteria, we have extended
the CPG ontology by adding the hasNumericValueForCardinality and hasCardinalityType properties and the CardinalityType

390

IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 20, NO. 1, JANUARY 2016

class with instances any, all, min and max. Using TURTLE syntax, we represent the condition satisfaction criterion of the task
remove_foreign_bodies as follows:

:remove_foreign_bodies :hasCondition
:foreign_body_visible,
:conjunctival_foreign_body_present,
:corneal_foreign_body_present.
:hasCardinalityType :min;
:hasNumericValueForCardinality
‘‘2’’ˆˆxsd:int.

B. Expressions in CPG Ontology
Expressions play a pivotal role in translation of patients’ quantitative data to medical concepts used in generating personalized
CPG-mediated therapy plans. For instance, body mass index
with a predefined threshold will assign a person to one the underweight, normal, overweight, or obese categories. To handle
expressions which are not supported in CPG ontology [27], we
extended it using instances, classes and properties described in
this section. We explain our solution through this example: The
CPG for AF recommends to “decrease weekly warfarin dose by
20%” if the result of the international normalized ratio (INR) test
is greater than 10. To model this expression, we compare the latest INR test result (latest_INR) with value 10 (INR_Threshold)
in the function compINRFunc and put the results in the output
Boolean variable Is_INR_Greater_Than_10? as shown below

:compINRfunc a :Function;
:hasInputVar1 :latest_INR;
:hasInputVar2 :INR_threshold;
:hasOperator :gt; # Greater Than
:hasOutputVar :Is_INR_Greater_Than_10?.
:INR_threshold :hasValue ‘‘10’’ˆˆxsd:float.

We then use variable Is_INR_Greater_Than_10? as the condition of the calculate_New_Warfarin_Dose function as shown
below

:calculate_New_Warfarin_Dose a :Function;
:hasInputVar1 :current_Warfarin_dose;
:hasInputVar2 :new_Warfarin_Dose_Coefficient;
:hasOperator :multiply;
:hasOutputVar :new_Warfarin_Dose.
:hasCondition :Is_INR_Greater_Than_10?
:new_Warfarin_Dose_Coefficient :hasValue
‘‘0.4’’;# 80%.

If value of the latest_INR numerical variable is greater than
10, the output variable new_Warfarin_Dose will contain the
new value for the warfarin dose. Therefore, our CPG execution
engine can represent complex expressions based on patient’s
physiological attributes to choose the next step to be executed.
In Section VII, we illustrate how we calculate the output of
expressions.

Fig. 1.

Our decision support system architecture.

IV. CPG-BASED CDSS
In this section, we briefly describe the CDSS environment in
which the CPG execution engine operates. Fig. 1 shows the three
main components of a CDSS: 1) a triple store, 2) CPG execution
engine, and 3) execution engine clients. These components are
briefly discussed below.
A. Triple Store
A triple store is a database optimized for storage and retrieval
of triples. We use Jena triple store [31] to store the following
datasets used during CPG execution:
1) Execution Trace: Since the CPG execution is not limited
for a single patient–physician encounter (especially for a
chronic disease patient), we need to log the execution trace
for each individual patient to execute the CPG at future
encounters. For example, if the measure_BP task is completed for a patient, his CPG Execution Status data set will
contain the following triple “:measure_BP hasTaskState
:completed.”
2) CPG Repository: The CPG repository contains the CPG
ontology and its instantiations that represent computerized
CPG.
3) Electronic Medical Record (EMR): We store the patient
medical records as OWL triples so that this information
can be reasoned over by the OWL-based execution engine. For instance, the fact that patient1 has a systolic
blood pressure measurement is represented by the following triples:
:patient1 :hasMeasurement :Systolic_BP1.
:Systolic_BP1 :hasValue ‘‘123’’;
:hasMeasurementDate ‘‘2014--09--12.’’

B. OWL-Based CPG Execution Engine
We developed three CPG execution engines that use OWL
1 DL, OWL 2 DL, and OWL 2 DL + SWRL to define CPG
workflow execution semantics. RESTful API exposed by the

JAFARPOUR et al.: EXPLOITING SEMANTIC WEB TECHNOLOGIES TO DEVELOP OWL-BASED CLINICAL PRACTICE GUIDELINE

391

CPG-j’s tasks for patient-i. In the remainder of this section, we
discuss the execution semantics and the ontology-based CPG
execution algorithm that is run in the OWL 1 DL-based CPG
execution engine.
A. CPG Execution Semantics in OWL 1 DL

Fig. 2. OWL 1 DL-based CPG execution engine shown in Fig. 1 and its
components.

CPG execution engine can be used by any number of execution engine clients to connect to the CPG execution engine.
When CPG execution engine is notified by the execution engine client through the RESTful API that decision support is
needed for a patient-i based on CPG-j, CPG execution engine
retrieves, patient-i’s medical record from EMR, the CPG ontology instantiation representing CPG-j and the CPG execution
semantics from the CPG repository, and the related execution
trace pertaining to progress of patient-i in CPG-j. Subsequently,
execution engine performs reasoning on the loaded triples and
infers the next task to be executed for patient-i according to
CPG-j.
C. Execution Engine Client
The execution engine client provides a user interface to interact with the CPG execution engine through the available
RESTful API. The client allows users to follow CPG actions,
provide feedbacks, and monitor CPG execution during patient–
physician encounters.
V. OWL-DL-BASED EXECUTION OF CPGS
In this section, we describe the main components of the OWL
1 DL-based CPG execution engine (see Fig. 2). These components are: 1) A Jena ontology model is a Java object used to
load, manipulate, and save ontologies. To provide decision support to patient-i based on the CPG-j, patient-i’s medical record
from EMR, the CPG ontology instantiation representing CPG-j
and the CPG execution semantics from the CPG repository, and
the related execution trace pertaining to progress of patient-i in
CPG-j are loaded in this Jena ontology model. 2) An OWL reasoner (see [21]) to perform reasoning on the triples stored in the
Jena ontology model. 3) The ontology-based CPG execution algorithm that is run in order to find the new executional states of

As the base CPG execution engine, we use OWL 1 DL to
express the execution semantics as it is the most expressive yet
decidable sublanguage of OWL 1 [32]. In this CPG execution
engine, the execution semantics are implemented as a set of
triples in OWL 1 DL to represent: 1) the transition of CPG
tasks between different executional states during execution at
the point of care and 2) a set of rules governing the satisfaction
of condition criteria for the CPG tasks. Below, we elaborate on
each of these execution semantics components.
1) State Transition Model in OWL 1 DL: CPG tasks go
through different executional states such as active or completed
during CPG execution. In real world clinical settings, physicians keep track of these executional states. In order to execute CPG in a computer, we model executional states of CPG
tasks and their transitions in clinical settings by a state transition model. Our execution state transition model is composed
of five execution states—i.e., inactive, active, underExecution,
completed and discarded—where each CPG task during execution is in one of these executional states. These execution states
are represented as instances of the TaskState class. The property
hasTaskState with the domain of Task and range of TaskState
is used to assign execution states to a CPG task. Depending
on the value of this property, a task can belong to one of the
InactiveTask, ActiveTask, UnderExecutionTask, CompletedTask
and DiscardedTask classes, where each class represents an execution state. The transition of a task from one state to another
is implemented using a set of transition rules defined using
OWL 1 DL axioms. Note that for each state transition there
are multiple transition rules to account for a range of execution
scenarios.
We discuss below the workings of the execution state transitions for a small part of the CHF CPG [27] shown in Fig. 3.
In this figure, property hasNext represents the sequential constraint between two tasks (e.g., :adjust_NA :hasNext :adjust_K),
hasTask property is used to indicate subtask of a composite
task (e.g., adjust_NA :hasTask :correct_NA), property hasFirstTask (subproperty of hasTask) represents the task that should
be executed first among subtasks of a composite task (e.g.,
:adjust_NA :hasFirstTask :assess_Serum_NA) and property
hasOutcome represents possible outcomes of a medical task
(e.g., :assess_Serum_NA :hasOutcome :NA< = 134 mEq/L).
CPG in Fig. 3 is composed of three tasks called ajdust_CR,
adjust_NA and adjust_K with labels “Assessment and Adjustment of Serum Creatinine,” “Assessment and Adjustment of
serum NA” and “Assessment and Adjustment of serum K,” respectively. These tasks are ordered as follows: ajdust_CR →
adjust_NA → adjust_K. Subtasks of the task adjust_NA have
the following ordering: assess_Serum_NA → correct_NA →
recheck_NA. For simplicity, subtasks of the rest of the composite tasks are not shown in Fig. 3.

392

IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 20, NO. 1, JANUARY 2016

insert the triple “:correct_NA :hasTaskState :underExecution”
in the CPG execution trace for that patient.
UnderExecution → Completed.
An underExecution atomic task will go the completed state
if the notice about its successful fulfillment is generated by the
user through the execution engine client. Similar to active →
underExecution state transition, no rule is needed to implement
this state transition as it is user-initiated as opposed to it being
inferred. An underExecution composite task, will be regarded as
completed when all its subtasks (indicated by hasTask property)
are completed using the following rule:
CompositeTask  UnderExecutionTask 
∀hasTask.(Completedtask)  hasNewTaskState.{completed}

InactiveTask or UnderExecutionTask or ActiveTask → Discarded.

Fig. 3. Subguideline of the CH CPG taken from [27]. Diamonds represent
tasks with outcomes (or inquiries), circles represent outcomes/conditions, and
rectangles represent medical tasks.

We use DL notation to represent the state transition rules
that are actually modeled in OWL due to its brevity compared
to TURTLE or RDF/XML syntaxes. In these formulas, values
of the property hasNewTaskState with the domain of Task and
range of TaskState represent the next executional states of the
CPG tasks that should be assigned to them. Below, we elaborate
on the state transition rules
Inactive → Active.
A typical scenario in which an inactive task becomes active
is that: 1) Its condition criterion has been satisfied—i.e., it is
an instance of the class TaskWithSatisfiedCriterion. 2) Its previous task is completed. This state transition rule is expressed as
follows in DL notation:
InactiveTask  ∃hasNext− .CompletedTask 
TaskWithSatisfiedCriterion
∃hasNewTaskState.{active}.

Example 1. Consider a scenario in which task
assess_Serum_NA is completed and its outcome “NA<
= 134 mEq/L” is marked as a satisfied condition. The follow-up
task correct_NA which was initially inactive will become active
due to the firing of the inactive-active transition rule above.
Active → UnderExecution.
User can select an active task to undergo execution, which
will result in the task moving from the active state to the
underExecution state by the execution engine; this is represented
by the change in the value of the hasTaskState from active to
underExecution. Since this state transition is not inferred but
initiated by the user, no rule is needed to implement this state
transition.
Example 2. Continuing with Example 1, as the user selects
to execute the task correct_NA, the CPG execution engine will

Several rules govern this state transition. As an example of
this state transition rule, an inactive task will be discarded if its
condition satisfaction criterion has not been met
InactiveTask  TaskWithUnsatisfiedCriterion
 hasNewTaskState.{discarded}.

Example 3. Imagine an execution scenario of CPG shown
in Fig. 3 in which after completion of assess_Serum_NA, outcome NAࣘ = 134 mEq/L is marked as a false Boolean outcome
by the user. Since this outcome is the only condition of the task
correct_NA, this task will not meet its condition satisfaction criterion. Therefore, this task will be discarded via the above rule.
We will discuss later in the paper how an OWL reasoner can infer
whether the condition satisfaction criterion has been met or not.
Completed or Discarded → Inactive.
CPG tasks that are to be repeated over a number of times—
i.e., they are part of an iterative task—are transitioned to the
inactive state at the end of each execution iteration. This allows
these tasks to be selected for activation during the next iteration.
For instance, if all subtasks of a while-loop are completed or
discarded and its continuation condition is still satisfied, all the
subtasks should go to the inactive state for a new iteration.
Please note that all the aforementioned state transition rules
are written manually and are valid for execution of any instantiation of the CPG ontology. As a result, when a new paper-based
CPG is computerized these rules are reused.
2) Condition Handling Triples in OWL 1 DL: Condition
handling triples are also a part of the execution semantics in our
OWL-based CPG execution engine. A task may belong to one of
the TaskWithSatisfiedCriterion or TaskWithUnsatisfiedCriterion
depending on the status of its conditions. Our OWL 1 DL-based
execution engine is capable of handling “any” and “all” condition satisfaction cardinalities. The following fact indicates that
if a task has condition satisfaction criterion of any and all its
conditions are satisfied, it is a member of the TaskWithSatisfiedCriterion
∃hasConditionCriterion.{any} 
∃hasCondition.SatisfiedCondition 
TaskWithSatisfiedCriterion.

JAFARPOUR et al.: EXPLOITING SEMANTIC WEB TECHNOLOGIES TO DEVELOP OWL-BASED CLINICAL PRACTICE GUIDELINE

Fig. 4.
rithm.

Example CPG in step 1 of the ontology-based CPG execution algo-

Other condition satisfaction cardinalities such as minimum k
out of n conditions are not possible to be handled in OWL 1 DL
due to lack of qualified cardinality restrictions.
Example 4. The condition satisfaction criterion of the task
adjust_K shown in Fig. 3 is any. This task will be an instance
of the TaskWithSatisfiedCriterion when either NAࣙ134 mEq/L
or NAࣙ134 mEq/L after appropriate measures is an instance of
the SatisfiedCondition class.
B. Ontology-Based CPG Execution Algorithm
Ontology-based CPG execution algorithm is run in the CPG
execution engine when it is consulted for decision support
through an execution engine client. To understand how this execution algorithm works, we show it in action for a small part of
the CPG shown in Fig. 3 composed of assess_Serum_NA and
correct_NA tasks and NAࣘ = 134 mEq/L outcome/condition
and go through its execution starting from Fig. 4. The following
steps show how the ontology-based CPG execution algorithm
works:
Step 1: Load the required data sets.
Upon a request from the execution engine client for decision
support, the CPG execution engine loads the CPG execution
semantics, an instantiation of the CPG ontology representing a
CPG such as CHF CPG, the patient’s medical record and his/her
progress in the loaded CPG in the Jena ontology model from
Jena triple store. If during the last physician–patient encounter,
assess_Serum_NA became activated but was not executed, the
executional states of assess_Serum_NA and correct_NA are active and inactive, respectively, as they are annotated in Fig. 4.
Step 2: Send tasks’ states to the execution engine client.
The execution state of tasks as indicated by the value of
the property hasTaskState are communicated to the execution
engine client to be shown the user who is a health-care professional.
Step 3: Wait for task state change notifications by the execution engine client. Upon a state change, go to Step 4.
In this step, the ontology-based CPG execution algorithm
waits for the user to interact with the execution engine client.
Step 4: If a task is started, record the start of that task otherwise go to step 5.
The execution engine client uses the RESTful API to notify
the execution engine that the user has started execution of a task.
In our example, to record the start of task assess_Serum_NA
by the user, value of the property hasTaskState for this task
is replaced with underExecution in the CPG execution status.

Fig. 5.
rithm.

393

Example CPG in step 6 of the ontology-based CPG execution algo-

Since this state change does not cause any state transitions in
other tasks and no other tasks have been completed, execution
will go through steps 5→6→7→3 in our example. Therefore,
after finishing this step, execution engine is waiting in step 3 for
state changes.
Step 5: If a task is completed, record the completion of tasks
and values of their outcomes.
Similar to the step 4, upon completion of tasks by the user
using the execution engine client, the execution engine is notified of the state change so it can update the Jena ontology
model accordingly. In our example, when execution engine
client notifies the execution engine that assess_Serum_NA is
completed, execution will go from step 3 to this step and “:assess_Serum_NA :hasTaskState :underExecution” will be replaced by “:assess_Serum_NA :hasTaskState :completed” in
the CPG execution trace in the Jena ontology model. Moreover, values of the tasks’ outcomes are sent to the execution
engine. These values are assigned to their hasValue property
(“:NA< = 134 mEq/L :hasValue “true”ˆˆxsd:Boolean”) in the
Jena ontology model.
Step 6: Perform reasoning on CPG ontology instantiation to
find the next state of the tasks.
After making changes to the executional states of the tasks
in the Jena model ontology, reasoning is performed on it in
order to infer the new states of the tasks based on the data.
In our example, Pellet will infer that the task correct_NA has
the value active for the property hasNewTaskState based on the
inactive→active state transition rule. The result of this step is
shown in Fig. 5.
Step 7: Apply the new states of tasks that are inferred in the
previous step to them. If new states are assigned go to step 6
otherwise go to step 3.
Value of hasNewTaskState property representing the inferred
state replaces the value of the hasTaskState property for CPG
tasks by the CPG execution engine. Subsequently, all the triples
that have hasNewTaskState as their property are deleted from the
CPG execution status. At the end of this step, assess_Serum_NA
and correct_NA will have the values completed and active for
the property hasTaskState respectively. CPG execution engine
will go to step 3 and wait for the user to start execution of task
correct_NA.
VI. OWL 2-BASED CPG EXECUTION ENGINE
OWL 2 is the new version of OWL that offers several improvements such as user-defined data ranges and qualified cardinality

394

IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 20, NO. 1, JANUARY 2016

restrictions [33]. The OWL 2 DL-based execution engine builds
on the core CPG execution semantics offered by the OWL 1 DL
execution engine by using the following OWL 2 DL features: (1)
Modeling of and reasoning on qualified cardinality restriction
are used handle condition satisfaction criteria other than all or
any (e.g., minimum k out of n). 2) User-defined data ranges are
used to handle comparisons of values of data type properties with
predefined values in the CPG. Because of these extensions, the
OWL 2 CPG execution engine is capable of executing CPG that
were not previously executable using OWL 1 DL-based CPG
execution engine. Apart from the aforementioned features, both
the OWL 1 DL and OWL 2 DL CPG execution engines share
the same core execution semantics.
A. Condition Handling Triples in OWL 2
We use qualified cardinality restrictions expressivity in OWL
2 to handle conditions satisfaction criteria that are not any or
all (e.g., minimum k out of n). As an example, suppose the condition satisfaction criterion of the task remove_foreign_bodies
from the management of ocular conditions nursing CPG [28]
is set as minimum 2 out of 3. For this CPG, we programmatically generate the following facts so that the reasoner will infer
that remove_foreign_bodies is an instance of TaskWithSatisfiedCriterion if minimum two of its conditions belong to the class
SatisfiedCondition:
1. TaskMin2SatCondition
(remove_foreign_bodies),
2. TaskMin2SatCondition 
(≥ 2 hasCondition.SatisfiedCondition) 
TaskWithSatisfiedCriterion.

B. Datatype Expressivity Triples in OWL 2
We utilize user-defined data ranges of OWL 2 to implement
expressions (see Section III-B), whereby the value of a data-type
property is compared to a predefined value, and the results are
consumed as a condition. For instance, to handle the INR comparison example at the end of Section III, we programmatically
assert the following fact in the execution semantics so that the
Is_INR_Greater_Than_10? output variable has the value true
when the value of the latest_INR is greater than 10:
1. Condition_GT_10
(Is_INR_Greater_Than_10?),
2. Condition_ GT_10  ∃isOutputOf.
(∃hasInputVar1.Numeric_Variable_GT_10)
SatisfiedCondition.

We use user-defined data ranges in OWL 2 as follows to define
the Numeric_Variable_GT_10 class which represents instances
that their hasValue datatype property value is greater than 10:
:Numeric_Variable_GT_10 owl:equivalentClass
[a owl:Restriction; owl:onProperty :hasValue;
owl:someValuesFrom
[a rdfs:Datatype; owl:onDatatype xsd:int;
owl:withRestrictions ([xsd:min
‘‘11’’ˆˆxsd:int])]
] rdfs:subClassOf NumericVariableGT10.

As an example, if the patient medical record includes the triple “:latest_INR :hasValue “13”ˆˆxsd:int”,
Is_INR_Greater_Than_10? will be an instance of the SatisfiedCondition class. Therefore, OWL 2 DL can compare values
automatically during execution, whereas in OWL 1 DL-based
CPG execution engine we had to show the latest INR value and
ask the user if this value is greater than 10 or not.
VII. SWRL-BASED CPG EXECUTION ENGINE
The OWL 2 DL + SWRL-based CPG execution engine enhances the OWL 2 DL CPG-based CPG execution engine by
adding SWRL rules to its execution semantics in order to: 1)
calculate expressions with mathematical and Boolean operators
and 2) execute iterative tasks. Therefore, this CPG execution
engine is the most advanced one as it can execute CPG with
complex constructs that were not previously executable using
OWL 1 DL or OWL 2 DL-based CPG execution engines. Apart
from the aforementioned extended capabilities, the core execution semantics of this execution engine is similar to that of the
other two execution engines. Below, we describe how SWRL
rules are incorporated within the execution semantics.
A. Calculating Mathematical and Boolean Operators Using
SWRL
To calculate expressions such as multiplication of the frequency of taking a pill by its strength to find the daily dose, we
have developed SWRL rules for each instance of the Operator
class (from CPG ontology in Section III-B). These SWRL rules
make use of SWRL’s built-in mathematical functions to calculate the output of functions in expressions. Below, we illustrate
the use of a SWRL rule that makes use of swrlb:multiply built-in
to calculate output of functions using the multiply operator
hasInputVar1(?f1,?inVar1)ˆ hasValue(?inVar1,?v1) ˆ
hasInputVar2(?f1,?inVar2)ˆ hasValue(?inVar2,?v2) ˆ
hasOutputVar(?f1,?outputVar)ˆ
hasOperator(?f1, multiply)ˆ
swrlb:multiply(?v1∗v2,?v1,?v2)→
hasValue(?outputVar,?v1∗v2).

B. Handling Iterative Tasks Using SWRL
OWL 1 DL and OWL 2-based CPG execution engines are unable to handle iterative tasks because they do support mathematical addition operator to count the iterations. A simple solution
to account for iterative tasks (for a given number of iterations)
is to add 1 to the value of a datatype property using swrlb:add
built-in operator when an iteration is completed. However, such
a rule is not DL-safe [34] as it uses the new value of that data
type property to fire the rule infinitely. To address this issue,
we have implemented a DL-safe solution by defining two data
type properties and using the swrl:add built-in function. The
hasCurrentItrNum property holds the current iteration number
and hasPreviousItrNum the previous iteration number and is set
to 0 at the beginning of the execution. The loop handling rules
operate as follows:

JAFARPOUR et al.: EXPLOITING SEMANTIC WEB TECHNOLOGIES TO DEVELOP OWL-BASED CLINICAL PRACTICE GUIDELINE

1) If the first task is active, then “current iteration number”
= “previous iteration number” + 1.
Loop(?l1)ˆ hasFirstTask(?l1,?ft)ˆ ActiveTask(?ft)ˆ hasPreviousItrNum(?l1,?n)ˆ
swrlb:add(?nPlus1,?n,1)→ hasCurrentItrNum(?l1,?nPlus1).

2) If the first task is started, then “previous iteration” =
“current iteration”:
Loop(?l1)ˆ hasFirstTask(?l1,?ft)ˆ StartedTask(?ft)ˆ hasCurrentItrNum(?l1,?n)→ hasPreviousItrNum(?l1,?n).

3) If the “current iteration number” > “maximum number of
iterations” then terminate the loop. This rule is not listed
here.
VIII. EVALUATION
We have evaluated our CPG execution engines from both
technical and medical standpoints. For medical evaluation, we
used two previously computerized CPG in an earlier version
of our CPG ontology [27]: 1) Canadian CHF CPG comprising five subguidelines: clinical history and exam, assessment of
test results, assessment of echocardiograph result, pretreatment
electrolyte assessment and correction and treatment of heart
failure. 2) Canadian AF CPG comprising four subguidelines:
clinical assessment and initial testing, assessment of left ventricular function, Stroke risk stratification and anticoagulation
and treatment of AF.
For technical evaluation, in addition to the CHF and AF CPG,
we also used six nursing CPG that were computerized using an
existing nursing CPG ontology [28]. The nursing CPG are management of ocular conditions CPG, prevention and treatment of
pressure ulcers CPG, management of heart failure CPG, adult
asthma care CPG, pediatric stoma CPG and management of
upper respiratory tract infections. For evaluation purposes, we
used 150 simulated clinical scenarios (ten for each of the nursing
CPG and the CHF and AF subguidelines) designed by a team
of medical practitioners. On average, each patient scenario contained 19.2 triples.
A. Technical Evaluation
We evaluated the efficiency of our CPG execution engines in
terms of CPU time and compared their recommendations with
existing CPG execution engines [14], [27].
1) Comparison of the Generated Recommendations With That
of the Existing CPG Execution Engines: Out of nine CHF
and AF subguidelines, seven subguidelines were executed using OWL 1 DL CPG execution engine as they contained basic
workflow patterns, one subguideline was executed using OWL
2 DL-based CPG execution engine as it contained complex condition satisfaction criteria and one subguideline was executed
using OWL 2 DL + SWRL-based CPG execution engine as it
contained an iterative task. We also executed each of the CHF
and AF subguidelines using their proprietary execution engine
[27] for the same ten scenarios used to evaluate our CPG execution engines. Our results showed no differences between the

395

recommendations generated by our CPG execution engines and
the proprietary developed CHF-AF CPG execution engine [27].
We repeated the same experiment for all six nursing CPG.
Out of six nursing CPG, four CPG were executed using OWL
1 DL CPG execution engine because they only contained basic
workflow patterns and 2 CPG were executed using OWL 2 DL
CPG execution engine as they both contained comparison of
quantitative patient data with predefined values besides basic
workflow patterns. OWL 2 DL + SWRL was not used to execute any of these CPG as it would be slower because of the extra
expressivity that is not needed. Execution results were exactly
the same for all nursing CPG and all scenarios in the appropriate
OWL-based CPG execution engine and the CPG execution engine that has been proprietary developed for nursing CPG [14].
From these two experiments, we conclude that our OWL-based
CPG execution engines have at least the same level of technical
validity as the CPG execution engines developed for nursing
CPG ontology [14] and CHF-AF CPG ontology [27].
2) Efficiency in Terms of CPU Time: For the test dataset
of 150 clinical scenarios, we measured the CPU time taken to
determine the next execution state for the CPG task. OWL 1 DL,
OWL 2 DL and OWL 2 DL + SWRL-based CPG execution
engines take 1.4, 3.6, and 5.5 s, respectively, on average to
find the new states of the CPG tasks on a PC equipped with
12 GB of RAM and an Intel Core i7-4770 CPU. The increase in
execution time is consistent with the increasing expressivity of
the CPG execution engines. Our results indicate that all of our
CPG execution engines are quite fast and their response time is
not a hindrance to their practical usage. Please note that different
CPG are executed using different OWL-based CPG execution
engines based on their level of expressivity. Hence, numbers
reported in this section are obtained by executing different set
of CPG in each of our OWL-based CPG execution engines.
B. Medical Evaluation
The medical evaluation of the output of the CPG execution
engines was based on the 90 clinical scenarios for CHF and AF
subguidelines, assessed by five general practitioners and two
cardiologists. Participants were asked to study the paper-based
CHF and AF CPG before evaluation and they had a hard copy
of these CPG during evaluation. The evaluators were asked to
classify the recommendations generated by the CPG execution
engine for all 150 clinical scenarios to one of five categories
listed in Table I.
Table II shows the cumulative response of the evaluators for
each subguideline based on the classification scheme presented
in Table I. An analysis of the evaluators’ responses indicates
that the CPG execution engines are generating CPG-mediated
recommendations that are consistent with the actual intent (and
content) of the CPG. However, there are some recommendations
that are medically correct but are deemed out of order. We
believe that evaluators assigned the generated recommendations
to categories other than “relevant in correct order” due to the
following reasons:
1) Different Interpretations of the Paper-Based CPG by Different Physicians: Physicians’ interpretation of a paper-based

396

IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 20, NO. 1, JANUARY 2016

TABLE I
CATEGORIES USED BY PHYSICIANS TO EVALUATE THE GENERATED
RECOMMENDATIONS BY OWL-BASED CPG EXECUTION ENGINES AND THEIR
DESCRIPTIONS
Recommendation Category

Description

Relevant in correct order

Relevant to the current patient scenario and
the participant physician would perform it
after the previous recommendation.
Relevant to the current patient scenario;
however, the participant physician would
not perform this action after the previous
recommendation.
Relevant to the current patient scenario;
however, modifications are needed.
Irrelevant to the current patient scenario.
Perilous in the current patient scenario.

Relevant in wrong order

Relevant but needs modification
Irrelevant
Dangerous

TABLE II
PERCENTAGE OF TASKS IN EACH SUBGUIDELINE ASSIGNED TO EACH
CATEGORY OF TABLE I BY PARTICIPANTS ACROSS TEN PATIENT SCENARIOS

CHF: Clinical
History and
Exam
CHF:
Assessment of
Test Results
CHF:
Assessment of
echocardiograph
Result
CHF:
Pretreatment
Electrolyte
Assessment
and
Correction
CHF:
Treatment of
Heart Failure
AF: Clinical
Assessment
and Initial
Testing
AF:
Assessment of
left ventricular
function
AF: Stroke
Risk
Stratification
and Anticoagulation
AF: Treatment
of Atrial
Fibrillation

Relevant
correct
order

Relevant
incorrect
order

Relevant
but needs
modification

Irrelevant

100%

0%

0%

0%

0%

91%

0%

9%

0%

0%

72%
69%

0%
19%

28%
12%

0%
0%

0%
0%

64%

12%

15%

4%

5%

93%

0%

7%

0%

0%

77%

0%

23%

0%

0%

84%

4%

12%

0%

0%

44%

34%

22%

0%

0%

Dangerous

CPG at times is subjective—they have personal preferences that
factor in their interpretation and use of a CPG. Other times the
CPG are ambiguous in their determination and hence physicians take an interpretation that is different from that of other
physicians [35]. This is quite apparent in our case as well. For
example, according to tree of the evaluators the term “risk of
bleeding with anticoagulation therapy” in AF CPG can have

varying interpretations, whereas for CPG computerization and
execution purposes a distinct interpretations was used.
2) Disagreement With the CPG: Physicians may disagree
with the content of the CPG for various reasons such as inertia
of previous practices [36]. For instance, one of participants in our
evaluation did not agree with the 220-mmol/L cut off value for
abnormal serum creatinine test in the CHF CPG and suggested
to utilize values used in local Halifax hospitals which were
different from what the CPG stipulate.

IX. CONCLUDING REMARKS
In this paper, we have demonstrated the use of OWL to represent execution semantics of computerized CPG and OWL reasoning to execute them. To demonstrate the potential of OWL
reasoning, we developed three OWL-based CPG execution engines, each offering different executional capabilities. Table III
shows the capability of each of the OWL-based execution engines in CPG execution.
Table III shows which version of the OWL-based CPG execution engine is utilized to execute a computerized CPG based on
existence of specific workflow patterns. For instance, if a task
in a CPG has condition satisfaction criteria of minimum k and
no expressions or iterative tasks are present, OWL 2 DL execution engine will suffice. Execution of this CPG in OWL 2 DL+
SWRL-based CPG execution engine will have the same results
as the OWL 2 DL-based CPG execution engine, but it will be
slower because of extra expressivity which in fact is not needed
in this case. For efficiency reasons, it is recommended to avoid
more expressive CPG execution engines if higher expressivity
is not needed.
Since we define CPG execution semantics using a formal
knowledge representation language, we achieve benefits of
reasoning-based CPG execution approaches, which are: 1) increased shareability of computerized CPG, 2) flexibility of
switching to different implementation technologies, and 3) possibility of formal analysis including evaluation of decidability and computational complexity. Therefore, our framework
achieves the benefits of the reasoning-based CPG execution
approaches and offers the following two advantages in comparison to the existing semantic web-based CPG execution engine
that intertwine execution semantics and workflow structure in
SWRL rules [8]–[10].

A. Separation of Execution Semantics and Workflow Structure
Due to this separation, execution semantics can be reused
in other CPG computerized in our framework. Hence, computerizing paper-based CPG is less error-prone and faster in our
framework compared to existing frameworks that require definition of the execution semantics for every newly computerized
CPG. Additionally, changes to the workflow structure in our
approach does not have any effect on the execution semantics
and vice versa, and this allows to account for CPG updates or
even updates to the execution semantics.

JAFARPOUR et al.: EXPLOITING SEMANTIC WEB TECHNOLOGIES TO DEVELOP OWL-BASED CLINICAL PRACTICE GUIDELINE

397

TABLE III
CAPABILITIES OF DIFFERENT OWL-BASED CPG EXECUTION ENGINES

Basic workflow patterns
Condition satisfaction criteria other than all and any
Comparisons of patient values with predefined values
Expressions
Iterative tasks

OWL 1 DL

OWL 2 DL

OWL 2 DL + SWRL

+
−
−
−
−

+
+
+
−
−

+
+
+
+
+

±: partially supported, +: supported, −: not supported.

B. Enhanced Expressivity
Our framework is capable of executing far more complex CPG
compared to the existing semantic web reasoning-based CPG
execution engines. For instance, our CPG execution engines
are capable of execution CPG that contain complex condition
satisfaction criteria, iterative tasks, synchronization and parallel
split workflow patterns whilst existing frameworks do not have
any explicit construct for these patterns.
One might argue why OWL is preferred to other existing
languages with formal execution semantics such as Petri nets.
OWL is different in the following aspects: 1) Maintenance: Using OWL, there is no need to translate CPG to a different knowledge representation language and execution is native to OWL.
Translating makes tracing back issues to the actual computerized
CPG challenging. 2) Shareability: Since CPG and execution semantics are represented in the same knowledge representation
language using OWL, less number of tools and standards are
needed to share and reuse computerized CPG. 3) Expressivity:
Petri nets and other languages with formal execution semantics
unlike OWL are not capable of representation of medical knowledge encapsulated in a CPG and do not have rule languages. 4)
Formal Analysis of CPG: These languages such as Petri nets
provide opportunities to analyze CPG from several aspects such
as reachability that are of interest in CPG representation and
execution.
We conclude this paper with some suggestions for future
study: 1) Our framework does not support representation of
and reasoning on temporal constraints in CPG. Incorporating
these features will improve usability of our CPG execution engines. 2) OWL ontologies representing languages with formal
execution semantics such as petri-net ontology [35] can be utilized to represent computerized CPG in order achieve benefits
of these formal languages such as possibility of formal analysis
of computerized CPG besides what is offered by OWL for CPG
execution.
ACKNOWLEDGMENT
The authors would like to thank W. V. Woensel for his meticulous review of the paper.
REFERENCES
[1] S. H. Woolf, R. Grol, A. Hutchinson, M. Eccles, and J. Grimshaw, “Clinical guidelines: Potential benefits, limitations, and harms of clinical guidelines,” Br. Med. J., vol. 318, no. 7182, pp. 527–530, 1999.

[2] M. D. Cabana, C. S. Rand, N. R. Powe, A. W. Wu, M. H. Wilson,
P. A. C. Abboud, and H. R. Rubin, “Why don’t physicians follow clinical
practice guidelines? A framework for improvement,” J. Amer. Med. Assoc.,
vol. 282, no. 15, pp. 1458–1465, 1999.
[3] P. A. de Clercq, A. Hasman, J. A. Blom, and H. H. M. Korsten, “Design
and implementation of a framework to support the development of clinical
guidelines,” Int. J. Med. Inform., vol. 64, no. 2–3, pp. 285–318, 2001.
[4] M. A. Musen, S. W. Tu, A. K. Das, and Y. Shahar, “EON: A componentbased approach to automation of protocol-directed therapy,” J. Amer. Med.
Inform. Assoc., vol. 3, no. 6, pp. 367–387, 1996.
[5] D. R. Sutton and J. Fox, “The syntax and semantics of the PROforma
guideline modeling language,” J. Amer. Med. Assoc., vol. 10, no. 5,
pp. 433–443, 2003.
[6] S. Quaglini, M. Stefanelli, A. Cavallini, G. Micieli, C. Fassino, and C.
Mossa, “Guideline-based careflow systems,” Artif. Intell. Med., vol. 20,
no. 1, pp. 5–22, 2000.
[7] S. Skonetzki, H.-J. Gausepohl, M. van der Haak, S. Knaebel, O. Linderkamp, and T. Wetter, “HELEN, a modular framework for representing
and implementing clinical practice guidelines,” Methods Inf. Med., vol.
43, no. 4, pp. 413–26, Jan. 2004.
[8] M. A. Casteleiro and J. J. Des Diz, “Clinical practice guidelines: A case
study of combining OWL-S, OWL, and SWRL,” Knowl.-Based Syst., vol.
21, no. 3, pp. 247–255, 2008.
[9] M. Arguello Casteleiro, J. Des, M. J. Prieto, R. Perez, and H. Paniagua, “Executing medical guidelines on the web: Towards next generation
healthcare,” in Proc. 28th SGAI Int. Conf. Artif. Intell., 2009, pp. 545–551.
[10] M. Ceccarelli, A. Donatiello, and D. Vitale, “KON3: A clinical decision
support system, in oncology environment, based on knowledge management,” in Proc. 20th IEEE Int. Conf. Tools Artif. Intell., 2008, pp. 206–210.
[11] T. Oliveira, P. Novais, and J. Neves, “Representation of clinical practice
guideline components in OWL,” in Trends in Practical Applications of
Agents and Multiagent Systems. New York, NY, USA: Springer, 2013.
[12] D. Isern, D. Sánchez, and A. Moreno, “Ontology-driven execution of
clinical guidelines,” Comput. Methods Programs Biomed., vol. 107, no. 2,
pp. 122–139, 2012.
[13] Y. Ye, Z. Jiang, X. Diao, D. Yang, and G. Du, “An ontology-based hierarchical semantic modeling approach to clinical pathway workflows,”
Comput. Biol. Med., vol. 39, no. 8, pp. 722–732, Aug. 2009.
[14] M. A. Din, S. S. R. Abidi, and B. Jafarpour, “Ontology based modeling
and execution of nursing care plans and practice guidelines,” Stud. Health
Technol. Inform., vol. 160, pp. 1104–1108, 2010.
[15] A. Daniyal, S. R. Abidi, and S. S. R. Abidi, “Computerizing clinical pathways: Ontology-based modeling and execution,” Stud. Health Technol.
Inform., vol. 150, pp. 643–647, 2009.
[16] M. Peleg, “Computer-interpretable clinical guidelines: A methodological
review,” J. Biomed. Inform., vol. 46, pp. 744–763, 2013.
[17] D. Beckett and T. Berners-Lee. (2014). Turtle-terse RDF triple language
[Online]. Available: http://www.w3.org/TeamSubmission/turtle/
[18] B. McBride, “Jena: A semantic web toolkit,” IEEE Internet Comput.,
vol. 6, no. 6, pp. 55–59, Nov./Dec. 2002.
[19] M. Horridge and S. Bechhofer, “The OWL API: A java API for OWL
ontologies,” Semantic Web, vol. 2, no. 1, pp. 11–21, 2011.
[20] A. Katifori, C. Halatsis, G. Lepouras, C. Vassilakis, and E. Giannopoulou,
“Ontology visualization methods—A survey,” ACM Comput. Surv., vol.
39, no. 4, Nov. 2007.
[21] E. Sirin, B. Parsia, B. C. Grau, A. Kalyanpur, and Y. Katz, “Pellet: A
practical OWL-DL reasoner,” Softw. Eng. Semant. Web, vol. 5, no. 2, pp.
51–53, 2007.
[22] SPARQL 1.1 query language. (2014). [Online]. Available: http://www.
w3.org/TR/sparql11-query/

398

IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 20, NO. 1, JANUARY 2016

[23] D. Wang, M. Peleg, S. W. Tu, A. A. Boxwala, O. Ogunyemi, Q. Zeng, R.
A. Greenes, V. L. Patel, and E. H. Shortliffe, “Design and implementation
of the GLIF3 guideline execution engine,” J. Biomed. Inform., vol. 37, no.
5, pp. 305–318, 2004.
[24] Y. Shahar, S. Miksch, and P. Johnson, “The asgaard project: A taskspecific framework for the application and critiquing of time-oriented
clinical guidelines,” Artif. Intell. Med., vol. 14, no. 1–2, pp. 29–51, 1998.
[25] N. Hashemian and S. S. R. Abidi, “Modeling clinical workflows using business process modeling notation,” in Proc. 25th IEEE Int. Symp.
Comput.-Based Med. Syst., 2012, pp. 1–4.
[26] D. Isern and A. Moreno, “Computer-based execution of clinical guidelines: A review,” Int. J. Med. Inform., vol. 77, no. 12, pp. 787–808, 2008.
[27] S. R. Abidi, “A knowledge management framework to develop, model,
align and operationalize clinical pathways to provide decision support for
comorbid diseases,” Ph.D. dissertation, Faculty Comput. Sci., Dalhousie
Univ., Halifax, NS, Canada, 2010.
[28] M. A. Din, “Ontology modeling for nursing care plans and clinical practice
guidelines,” M.S. thesis, Faculty Comput. Sci., Dalhousie Univ., Halifax,
NS, Canada, 2009.
[29] A. Daniyal, S. R. Abidi, and S. S. R. Abidi, “Computerizing clinical pathways: Ontology-based modeling and execution,” Stud. Health Technol.
Inform., vol. 150, pp. 643–647, 2009.
[30] S. R. Abidi, “A conceptual framework for ontology based automating
and merging of clinical pathways of comorbidities,” in Knowledge Management for Health Care Procedures. Berlin, Germany: Springer, 2009,
pp. 55–66.
[31] (2014). Apache jena-TDB [Online]. Available: http://jena.apache.org/
documentation/tdb./
[32] (2014). OWL web ontology language guide [Online]. Available:
http://www.w3.org/TR/owl-guide./
[33] (2014). OWL 2 web ontology language document overview (second edition) [Online]. Available: http://www.w3.org/TR/owl2-overview./
[34] B. Motik, U. Sattler, and R. Studer, “Query answering for OWL-DL with
rules,” Rules Syst., vol. 3, no. 1, pp. 41–60, 2005.
[35] F. Zhang, Z. M. Ma, and S. Ribaric, “Representation of petri net with
OWL DL ontology,” in Proc. 8th Int. Conf. Fuzzy Syst. Knowl. Discovery,
2011, pp. 1396–1400.
[36] W. M. Tierney, J. M. Overhage, B. Y. Takesue, L. E. Harris, M. D. Murray,
D. L. Vargo, and C. J. McDonald, “Computerizing guidelines to improve
care and patient outcomes: The example of heart failure,” J. Amer. Med.
Inform. Assoc., vol. 2, no. 5, pp. 316–322, Sep./Oct. 1995.

Borna Jafarpour received the Bachelor’s and Master’s degree in computer engineering from the Amirkabir University of Technology, Tehran, Iran, and the
Ph.D. degree in computer science from Dalhousie
University, Halifax, NS, Canada.
He is a Postdoctoral Fellow at Dalhousie University. He conducts research in areas of machine learning, swarm intelligence, semantic web, and health informatics. His current research interests include modeling and execution of clinical workflows, developing
guideline-based clinical decision support systems for
comorbid patients, mapping clinical knowledge bases and alert fatigue prevention in medical alert systems.

Samina Raza Abidi received the Bachelor of
Medicine and Bachelor of Surgery degree in 1992
from Dow Medical College, University of Karachi,
M.Sc. degree in IT, and the Ph.D. degree in health
informatics both from Dalhousie University in 2001
and 2010.
She is a Faculty Member in Medical Informatics
Program, Faculty of Medicine, Dalhousie University,
Halifax, NS, Canada. She has a unique skill-set where
she is a clinician with an expertise in health informatics. Her research interests include health knowledge
management, clinical decision support, health knowledge modeling and computerization, patient-centered care, comorbid care planning, health systems evaluation. She is the PI and Co-PI for several government and industry-funded research grants and has published numerous peer-reviewed articles. She routinely
serves as a reviewer for international journals and conferences. She teaches
health informatics topics in the Master of Health Informatics Program and supervises a number of medical informatics graduate theses.
Dr. Abidi is the Recipient of the prestigious Steven Huesing Award 2007 by
Canada’s Health Informatics Association and CIHR Canada Graduate Scholarship Doctoral Award (2006–2009).

Syed Sibte Raza Abidi received the Master’s degree
in computer engineering from the University of Miami, Coral Gables, FL, USA, and the Ph.D. degree
in computing sciences from the University of Surrey,
Guildford, U.K.
He is a Professor of computer science and the
Director of health informatics at the Faculty of Computer Science, Dalhousie University, Halifax, NS,
Canada. He conducts research in the areas of health
informatics, knowledge management, semantic web,
and data analytics. His current research focuses on
clinical decision support systems, computerization of paper-based clinical
guidelines, clinical workflow analysis, knowledge translation, personalized patient empowerment programs, health data analytics and mobile health. He leads
the Knowledge Intensive Computing for Healthcare Enterprises research group
that comprises around 20 interdisciplinary researchers working in the general
area of health informatics. He has published more than 180 peer-reviewed research papers and has been involved in the supervision of more than 75 graduate
students. He serves on several scientific advisory and review boards for research
institutions, government agencies, and industry.
Dr. Abidi is the Recipient of the International Award for Innovation in Medical Informatics (2000), Research Excellence Award and five best paper awards.

