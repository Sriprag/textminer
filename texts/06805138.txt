IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 19, NO. 2, MARCH 2015

761

SecourHealth: A Delay-Tolerant Security Framework
for Mobile Health Data Collection
Marcos A. Simplicio Jr., Leonardo H. Iwaya, Bruno M. Barros, Tereza C. M. B. Carvalho, and Mats Näslund

Abstract—Security is one of the most imperative requirements
for the success of systems that deal with highly sensitive data, such
as medical information. However, many existing mobile health solutions focused on collecting patients’ data at their homes that do
not include security among their main requirements. Aiming to
tackle this issue, this paper presents SecourHealth, a lightweight
security framework focused on highly sensitive data collection applications. SecourHealth provides many security services for both
stored and in-transit data, displaying interesting features such as
tolerance to lack of connectivity (a common issue when promoting
health in remote locations) and the ability to protect data even if the
device is lost/stolen or shared by different data collection agents.
Together with the system’s description and analysis, we also show
how SecourHealth can be integrated into a real data collection
solution currently deployed in the city of Sao Paulo, Brazil.
Index Terms—Mobile health (mHealth), remote data collection,
security.

I. INTRODUCTION
HE Concept of mobile health (mHealth) comprises the
combination of mobile computing technology with medical sensors and communication devices, creating solutions for
improving health care [1]. The mHealth concept is also related
to that of electronic health processing, but while the latter is
more focused on fixed computing facilities (e.g., desktop computers), the former aims to explore more intensively the advances in wireless communication, ubiquitous computing, and
“wearable” device technologies [2].
Several socioeconomic factors contribute to the interest in
the mHealth trend. Examples include the broader availability of
high-end mobile devices, the growth in coverage of mobile cellular networks, and the necessity of actively bringing adequate
health care and support for people wherever they may be [3].
This attention around the mHealth area is spread all around the
globe, which has recently led the World Health Organization
(WHO) to develop surveys focused specifically on such solutions [3]. Applications surveyed include mobile telemedicine,

T

Manuscript received July 12, 2013; revised December 20, 2013; accepted
April 19, 2014. Date of publication April 24, 2014; date of current version
March 2, 2015. This work was supported by the Innovation Center, Ericsson
Telecomunicações S.A., Brazil, and in part by the Brazilian National Counsel of
Technological and Scientific Development (CNPq) under grants 482342/2011-0
and 473916/2013-4, as well as under research productivity grant 305350/20137.
M. A. Simplicio, L. H. Iwaya, B. M. Barros, and T. C. M. B. Carvalho
are with the Escola Politécnica, Universidade de São Paulo, 05508-900, São
Paulo, Brazil. (e-mail: mjunior@larc.usp.br; liwaya@larc.usp.br; bbarros@
larc.usp.br; carvalho@larc.usp.br).
M. Näslund is with the Ericsson Research 16483, Stockholm Sweden (e-mail:
sxstmats.naslund@ericsson.com).
Color versions of one or more of the figures in this paper are available online
at http://ieeexplore.ieee.org
Digital Object Identifier 10.1109/JBHI.2014.2320444

decision support systems, solutions for raising treatment compliance and awareness, electronic patient records (EPR), and
data collection systems for health surveys and surveillance, to
cite a few. Among the conclusions drawn from such studies is
the fact that, in the long run and after evaluation, mHealth solutions are expected to be integrated into and improve existing
country-wide health strategies [3].
The deployment of mHealth solutions is particularly promising in emerging countries, in which health authorities can take
advantage of the flourishing mobile market to bring adequate
health care to unserved or underserved communities [4]. Indeed,
specialized applications for health surveys and surveillance play
a crucial role in such regions, providing a rich repository for decision making on the field of public health [3], [5]. Applications
in this category typically involve remote data collection of Primary Health Care indicators, such as family-related data, sanitary conditions, identification of common diseases in a given
region, or tracking people with chronic conditions/diseases. The
data can be collected, for example, at health units located inside the target communities or during visits to the patients’
homes. This process is usually carried out by health teams that
include medical personnel (e.g., physicians and nurses) and/or
health agents responsible for specific regions [6]. The data are
then used by health authorities, allowing them to take effective
actions based on more accurate information about the health
conditions in the surveyed area. The advantage of using mobile
devices in this scenario, replacing paper forms traditionally employed for this purpose, is that data can be quickly validated by
the application and sent to a database using the mobile network,
increasing data reliability, and speed of decision making [7].
Despite its potential for effectively improving health and wellness, mHealth still faces many challenges for its widespread
adoption [3]. One important concern refers to security: even
though medical data are usually subject to a very strict legislation aiming to prevent unauthorized use or disclosure, many
mHealth proposals do not employ robust security solutions to
comply with such laws, hindering their ability to become real
deployments [8], [9]. Such concern is reflected in studies about
the security and privacy properties of nation-wide electronic
healthcare systems proposed in countries such as Germany [10]
and Canada [11]. It also appears in recent reports from organizations such as WHO [3] and the mHealth Alliance [12], which
point out that data security and citizen privacy are issues that
require more attention to ensure the success of mHealth initiatives. Another issue is that, while developed countries can usually benefit from a nearly ubiquitous mobile infrastructure, the
lack of such wide coverage in lower income countries becomes
an important constraint for the adoption of such technologies in

2168-2194 © 2014 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See http://www.ieee.org/publications standards/publications/rights/index.html for more information.

762

Fig. 1.

IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 19, NO. 2, MARCH 2015

Remote data collection scenario.

practice. Consequently, data collection solutions employed in
remote areas need to be delay tolerant and employ techniques
for locally storing acquired data in a secure manner, protecting
the patients’ privacy even when devices are shared by different
users or if they are stolen while still carrying some data [13].
Aiming to tackle such issues, this paper presents SecourHealth, a security framework focused on highly sensitive
data collection applications. SecourHealth includes many security features that address the specific challenges of mHealth data
collection, including support for services such as user and data
authentication, confidentiality of stored and in-transit data, and
tolerance to network disruption/delays. The proposed framework relies on very lightweight mechanisms, securing the data
exchanged with the server without requiring an extra security
layer, transport layer security/secure sockets layer (TLS/SSL),
except for the first time a user register in a new device. Aiming
to analyze SecourHealth’s performance, we also show how it
can be integrated into a real data collection solution, Geohealth
[6], which is currently being used in a pilot project in the city
of Sao Paulo, Brazil.

can then be accessed and analyzed using health management
systems.
Since data collection systems deal with sensitive information, both stored and in-transit data must be protected from
unauthorized access or modification. Otherwise, there may be
security breaches such as illegal disclosure to health insurance
or pharmaceutical companies, or simply to someone who steals
a mobile device and decides to publish socially sensitive health
conditions (e.g., AIDS or teenage pregnancy) on the Internet.
Such events are likely to affect people trust on the application
and discourage their participation in health programs involving
such systems [14], or even lead to lawsuits against those responsible for such programs. Therefore, to ensure the scalability and
longevity of such programs, proactive security measures should
be taken. There are, however, several constraints that must be
considered by any security framework targeted at mobile data
collection applications, especially when considering large scale
but low-budget projects usually found in developing countries.
In what follows, we discuss the main requirements involved in
the design of SecourHealth.

A. Tolerance to Delays and Lack of Connectivity
Many data collection systems are deployed in remote locations, where network access is not continuously available, implying that frequent connectivity losses are expected to occur
[15]. Consequently, the mobile device should be able to authenticate the user in an offline manner and also employ mechanisms
for temporarily storing acquired data in a secure manner, using
encryption. Even though an entirely offline mode of operation
should be allowed, if the data need to be delivered quickly, the
mobile device should be capable of doing so as soon as a communication channel is detected and without intervention from
the user, allowing a reasonably fast data upload process even in
regions with intermittent connectivity.

II. SCENARIO ASSUMPTIONS AND REQUIREMENTS
Data collection systems are mainly used as a tool for gathering
primary health care information and tracking existing diseases,
driving health promotion initiatives in the affected communities
[3]. Fig. 1 illustrates such systems, showing a generic architecture in which the paper forms traditionally employed for data
collection are replaced by a mobile device. Using the device’s
communication capabilities, data can be delivered in a faster and
more reliable manner, speeding up the whole process of decision
making. Key actors in this scenario are the health care workers,
who act as data collection agents and are responsible for visiting
families in their houses and for acquiring health-related information. During those visits, the agents fill out electronic forms
containing several questions designed for this specific purpose
and loaded into the mobile device. Partially filled forms (i.e.,
forms lacking mandatory information) are stored in the device’s
memory and, after consolidation, are delivered to the server
(e.g., via 3G or Wi-fi) together with the corresponding family’s
location. The server stores all received data in a database, which

B. Protection Against Device Theft or Loss
The mechanisms employed for temporary data storage should
also provide protection against unauthorized access or modification. Ideally, this protection should remain effective even if
the mobile device in which the data are stored is stolen, while
the user’s session is still active (i.e., the user is still “logged in”
to the device) and the device’s volatile memory is accessed. In
other words, the security solution should enable some level of
forward secrecy, preventing attackers from using information in
the device’s memory to access undelivered, locally stored data.
However, imposing forward secrecy may not be suitable for all
situations, since it may be useful to allow agents to recover
the information from previously saved forms, e.g., because they
were only partially filled or contained incorrect data. Hence,
the security framework should be flexible enough to support
different forward secrecy configurations according to the application’s needs.

SIMPLICIO JR. et al.: SECOURHEALTH: A DELAY-TOLERANT SECURITY FRAMEWORK FOR MOBILE HEALTH DATA COLLECTION

C. Secure Data Exchange Between Mobile Device and Server
To protect in-transit information, all data must be properly
encrypted before transmission to/from the server. In addition,
the security solution should provide the server with means to
verify if the data received actually came from a legitimate user,
thus preventing unauthorized entities from injecting (possibly
fake) information into the system’s database.
It is worth noting that conventional mechanisms for establishing secure connections (e.g., TLS/SSL) may not be the best
choice for data delivery in such applications [15], especially in
scenarios where the communication infrastructure is far from
ubiquitous and the devices have low computational power. This
happens because the data temporarily stored in the device already needs to be encrypted (as discussed in Section IIB.) and,
thus, adding an extra security layer for protecting its delivery
can be seen as an unnecessary overhead.
Aiming to create a solution that does not depend on secure
communication tunnels for data delivery, our approach is to
independently authenticate every piece of data that travels from
and to the mobile device. Therefore, and as further discussed in
Section III, the protocol itself has no strict need for creating and
authenticating a session before data delivery.
D. Lightweight and Low-Cost Solution
Low-budget projects may impose restrictions on the computational capabilities of the mobile devices employed for collecting data, including limitations on processing power and available memory. Therefore, the security framework should rely
as much as possible on lightweight cryptographic mechanisms
such as those based on symmetric keys (as opposed to publickey cryptography) during its operation [15]. Moreover, the security mechanisms deployed should not depend on hardware
capabilities not usually available in commercial mobile devices
(e.g., a tamper-proof module), although it should be able to take
advantage of such capabilities if present.
E. Device Sharing
Budget limitations or practical reasons may lead to the sharing
of mobile devices by multiple agents [15]. To cope with this
constraint, the security solution should allow access to registered
users from any (possibly multiple) devices in which the data
collection application is installed. Hence, users should be able
to share devices in a straightforward manner, without incurring
privacy and access control issues that might arise from a same
device carrying data from different agents.
F. Usability
In many deployments, the staff responsible for data collection may include people with little education background and/or
little experience with computers [7]. Even though this can be
overcame with intense training, frustrating experiences may become an extra barrier for the system’s acceptance. This is one of
the main reasons why many projects aiming to substitute paper
forms by electronic ones try to take into account the procedures

763

these professionals are already used to follow, aiming to facilitate migration to the new system [16].
Therefore, despite the need of strong security mechanisms
for protecting digital forms, it is important to keep in mind
that they must not impair the system’s usability. For example, although using some type of credential (e.g., username and
password) for user authentication is nearly unavoidable, users
should not have to repeatedly provide or memorize multiple credentials. In addition, after consolidation of the acquired data, its
delivery, encryption/decryption, and authentication/verification
should be done automatically and transparently, without requiring the user’s intervention.
III. THE SECOURHEALTH FRAMEWORK
In this section, we describe the SecourHealth framework and
its basic building blocks employed for fulfilling the requirements
described in Section II.
A. Preliminaries and Notation
Along the discussion, we assume that the user’s credentials for
accessing the system consist of a username usr and a password
pwd, provided to legitimate users at the system managers’ discretion. Typically, usr is provided by the system, while pwd is
chosen by the user and must have a minimum length, enforced
upon the user’s enrollment in the system. The SecourHealth
framework does not impose any specific limitation on how this
is done, however, as long as the server keeps a list of valid
(usr, pwd) pairs.
The following notation is used in the rest of this document.
We write |a| for the length, in bits, of string a and a  b for the
concatenation of strings a and b. Constant strings of characters
are written between single quotes (e.g., “string”). The notation
[s]t indicates the truncation of bitstring s to t bits, which is done
by taking the leftmost t bits of s.
−1
(M ) represent, respectively, encryption
EK (M ) and EK
and decryption of message M under key K. Similarly,
−1
(M ) denote the authenticated-encryption
AEK (M ) and AEK
and authenticated-decryption (i.e., the processes combining
encryption/authentication and decryption/verification [17]) of
message M under key K. The authentication tag generated by
a message authentication code (MAC) for a message M under
key K is written MACK (M ).
We write H(M ) to denote the application of a hash function
H on message M , and by H n (M ) the iterative application of H
on M , n times (note that H 0 (M ) = M ). We also write H[s] (M )
to denote the application of H on M after it is prepended
with an arbitrary bitstring s (i.e., H[s] (M ) = H(s  M )); hence,
n
(M ) indicates that s is prepended to the input of H before
H[s]
each of its n applications.
B. User Registration
The registration process must be performed whenever a user
accesses a mobile device for the first time. Since the device has
no information for authenticating the new user, this process requires connectivity to the server, which will be responsible for

764

Fig. 2.

IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 19, NO. 2, MARCH 2015

User registration process (online).

this first authentication. The successful completion of the registration protocol generates the information required for future,
offline authentications.
Without loss of generality, in the protocol description we
assume that the server keeps the user’s password pwd in its
database. We notice, however, that since security good practices
dictate that passwords should not be stored in plaintext, in real
implementations pwd may actually refer to some information
derived from the user’s password (e.g., its hash) rather than the
password itself.
The complete registration mechanism consists in a challengeresponse protocol described as follows (see Fig. 2).
1) The mobile application generates a random salt, which is
combined with the user-provided password by means of
a key derivation function (KDF). The result is the master
key MK = KDF (salt  pwd). The password itself can
then be erased from the device’s memory, since the registration process does not depend on its value from this
point on. There is no restriction on the exact KDF function
adopted for this process. A common approach is to employ the password-based key derivation function version 2
(PBKDF2) as defined in the PKCS#5 specification [18], or
more recent solutions such as Lyra [19]. The goal of such
algorithms is to ensure higher security against brute-force
attacks (also known as dictionary attacks) that explore
the low entropy of human-memorisable passwords: the
random salt thwarts the application of prebuilt tables of
common passwords, i.e., the attacker is likely to be forced
to create a new table from scratch for every different salt
value; in addition, the speed of the derivation process is
configurable (e.g., in PBKDF2, by the repeated application of a hash function), so that it is possible to raise
the computational cost of such attacks whereas the delay
perceived by a human user can remain negligible (e.g.,
around 1 s).
2) The mobile application then establishes a secure connection with the server, authenticating the latter and protecting the communication against eavesdropping from this
point on. Standard security solution such as TLS/SSL or
the generic bootstrapping architecture (GBA) [20], [21]

can be employed for this purpose. Under the protection of
this secure tunnel, the mobile application sends the user
identification usr together with the random salt generated
in step 1.
3) The server computes the master key MK using the user’s
password and creates a random seed value. The value of
seed plays an important role in providing forward secrecy
to locally stored data, as further discussed in Section IIID,
but during the registration it is used simply for creating a
challenge message.
4) The server issues a challenge to the mobile application: it
encrypts the random seed using the previously computed
master key MK, so that only a user who can compute the
same MK is able to recover the correct seed.
5) The mobile application uses MK computed in step 1 for
decrypting the value of seed. Then, it computes a shared
key K0 as K0 = H[seed] (MK) = H(seed  MK). As
further discussed in Section IIID, this key will be used for
providing (strong) forward secrecy to data locally stored
in the mobile device. At this point, however, it is used
simply for computing the response to the server’s challenge as MACK 0 (‘user ok’  usr  salt  seed), which
corresponds to the authentication tag of all previously exchanged variables together with a constant string.
6) The response is sent to the server.
7) The server computes the same K0 as the mobile application and verifies if the response provided by the latter
is valid, which implies that the mobile device was able
to recover the value of seed using the password input by
the user. In case of success, the server stores salt, seed,
and MK. These are associated with the corresponding
user and identify him/her in the registered device, whose
identification can also be stored for avoiding double registrations. The server also creates a positive assertion of
the form MACK 0 (‘serv ok’  usr  salt  seed).
8) The assertion generated in the previous step is sent to the
mobile application.
9) The mobile application verifies the received assertion using K0 and the value of seed computed in step 5. If the
verification is successful, this means that the user entered a
legitimate password, which was not certain until this point.
In this case, the application locally stores a) the value of
the salt used during the protocol and b) an authentication
token Auth = [MACMK (‘auth’)]tsiz e , which indicates
that the user is registered in this mobile device and allows him/her to perform offline authentications afterward.
Notice that the token is truncated to the system-defined
parameter tsize, something that is further discussed in
Section III-D.
Thereafter, the server can unregister any user simply by removing the entries for his/her username from its database.
C. Offline User Authentication
Users can employ their credentials to access the system from
any device in which they have previously registered, even in
case of lack of connectivity. After usr and pwd are provided

SIMPLICIO JR. et al.: SECOURHEALTH: A DELAY-TOLERANT SECURITY FRAMEWORK FOR MOBILE HEALTH DATA COLLECTION

Fig. 3.

User authentication process (offline).

by the user, the application employs the locally stored salt for
computing the master key MK as described in Section IIIB,
i.e., MK = KDF (salt  pwd). This key is then used for generating a verification token verif = MACMK (‘auth’), which
is compared with the authentication token Auth locally stored.
If [verif ]tsiz e matches the value of Auth, the user is authenticated and can access the application. This process is illustrated
in Fig. 3.
Note that a wrong password will be accepted in this offline verification process with probability 2−tlen . Accepting the
wrong password in this local authentication is not an issue from
a security point of view, since the master key MK generated
from such password will be invalid with overwhelming probability and, thus, will not be useful for creating or correctly
decrypting any valid data afterward. The goal of this local authentication is, thus, simply to give legitimate users a guarantee
that they are employing the correct keys while saving data, since
otherwise that data will become unrecoverable. Therefore, tlen
should be large enough so that, in practice, a mistaken password
never goes unnoticed by a legitimate user; on the other hand, a
small tlen gives less information for attackers trying to match a
guessed password to the stored value of Auth, since the probability of filtering wrong guesses will be only 2−tlen . If the users
of the system employ alphanumeric passwords, which typically
display approximately 40 bits of entropy on average [22], a reasonable approach is to adopt tlen = 20. This leads to a one in
a million chance of accepting the wrong password while still
forcing a brute-force attack to test approximately 220 unfiltered
password guesses against something other than Auth. Since the
security provided by this approach depends on how the master
key MK generated from it is used in the system, we leave this
discussion on password-guessing to Section III-D4.
D. Secure Data Storage
After the authentication process is completed and the master
key MK is computed from the user’s password, SecourHealth
generates keys that are used by an authenticated encryption
algorithm AE() for protecting each form saved. The system can
generate three types of keys, as described in the following. After
such keys are generated, the master key MK is immediately
wiped out of the device’s memory.
1) No Forward Secrecy (Knofs ): The Knofs key is computed
directly from the master key MK as Knofs = H(0  MK) and

765

is kept unchanged in the device’s volatile memory until the application is closed. This key should be used for protecting forms
that need to be easily recoverable during a session and that require no forward secrecy: its continuous availability in memory
allows a user to promptly decrypt Knofs -protected forms without
reentering his/her password, but, for this same reason, this key is
revealed to attackers who are able to access the device’s memory
(e.g., by stealing the device while the application is still open).
Knofs should be useful, for example, in applications that allow
users to save any number of partially filled forms and come back
to them later during the same session. If forms protected with
this key are delivered to the server, the latter can easily process them by computing the same Knofs = H(0  MK) from
the user’s master key. In addition, Knofs is also employed for
protecting data received from the server (see Section III-E) and
in the encryption of the Ksfs key (see Section III-D3).
2) Weak Forward Secrecy (Kwfs ): The Kwfs key provides
weak forward secrecy, in the sense that an attacker who accesses the device’s volatile memory, while the application still
running is unable to decrypt any Kwfs -protected form, but it does
not protect data against attackers who discover the user’s password. This key is computed at the start of the user’s session as
Kwfs = H[ses] (MK) = H(ses  MK), where MK is the master key and ses = 0 is a session number renewed in every session
(i.e., whenever a user reauthenticates him/herself). Right after
a form is encrypted and authenticated using Kwfs , this key is
replaced by the result of hashing it with ses once again, i.e., the
system makes Kwfs = H[ses] (Kwfs ) = H(ses  MK). In other
words, the iw th saved form will actually be protected using
ses,i w
iw
= H[ses]
(MK), each form being paired with its correKwfs
sponding value of ses and iw for allowing its subsequent decryption and authenticity verification. As a result, the device’s
volatile memory never holds the key required for decrypting
ses,i w
, but only the next, still unused,
a form protected by Kwfs
ses,i w +1
Kwfs
key. This type of key should be useful for protecting
consolidated forms that might require modification later, but not
too often: given the values of ses and iw , the user can access the
corresponding form simply by providing his/her password once
ses,i w
from the
again, which allows the system to compute Kwfs
resulting master key. The server follows an analogous process
to recover the contents of forms protected in this manner.
3) Strong Forward Secrecy (Ksfs ): The Ksfs key provides
strong forward secrecy, meaning that attackers are unable to
decrypt any Ksfs -protected form even if they discover the corresponding password or access the device’s volatile memory
while the application is still open. The reason is that this key is
computed as Ksfs = K0 = H(seed  MK) right after the completion of the registration process and, analogous to Kwfs , replaced by its hash value after being used to protect a form;
is
=
in other words, the is th saved form is encrypted using Ksfs
H i s (seed  MK). Since the mobile device does not store the
random seed, its value cannot be recovered using locally stored
information, no matter if the password is known. This property
also leads to the need of storing the next available Ksfs in the
device’s nonvolatile memory after usage since, unlike Kwfs ,
this key cannot be recomputed otherwise. In SecourHealth,

766

IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 19, NO. 2, MARCH 2015

i s +1
after the is th form is encrypted, Ksfs
is first encrypted
with Knofs and then stored, which allows users to recover their
next, still unused value of Ksfs while preventing any other user
sharing the device from doing the same. The improved security
provided by Ksfs is counterbalanced by the user’s inability to
modify the data after it is saved with this key, since the only
entity that is able to decrypt and verify forms protected in this
manner is the server itself. To do so, the server needs to be provided with 1) the value of the salt used for the corresponding
user’s registration, which identifies the value of seed and allows
the computation of K0 ; and 2) the value of is corresponding
to each form, which determines how many times K0 must be
is
.
hashed for obtaining the correct Ksfs
It is worth noting that attackers who discover the user’s password can violate the forward secrecy property of Ksfs if they
are able to recover the server’s challenge (see step 4 of the
registration protocol), whose decryption with the corresponding master key recovers the value of seed. Considering that this
message is protected by a secure tunnel, however, doing so requires the attacker to break the tunnel’s underlying protocol,
which should be infeasible against technologies such as TLS, or
compromise the server itself (who knows the value of seed), in
which case the data would not be secure anyway. Nonetheless,
if the attacker is somehow able to trick the user into creating
a tunnel with him/her rather than with the legitimate server, a
man-in-middle attack can be perpetrated and the security of the
protocol is lost. Namely, the attacker can relay all messages
between the user and the server, and then perform an offline dictionary attack on the keys established between them: the attacker
can compute a candidate M K  from salt and a guessed pwd,
compute seed and K0 from challenge and M K  , and then verify the guess by matching the user-provided response with
response = MACK 0 (‘user ok’  usr  salt  seed ). Avoiding such issue in the web may be a difficult challenge, since
many users tend to ignore warnings about certificate errors when
accessing websites [23], [24] and may end-up connecting to a
fake server. Notwithstanding, such a threat should be more easily
avoidable in the (presumably more controlled) scenario of data
collection solutions, in which the application itself can utterly
prevent users from making unsafe connections.
4) Key Generation and Usage—Summary: A good
password-based scheme should prevent attackers from easily
performing offline dictionary attacks, which are much harder
to detect than online attacks. This is the main motivation
of proposals that employ different passwords for different
purposes, such as authentication toward the server and toward
the devices (e.g., as proposed in [15]): in such cases, it is
easier to force the attacker to contact the server when trying to
verify the password shared only with this entity. This approach,
however, impairs the system’s usability, and may even create a
false sense of security since users may feel compelled to choose
similar (if not identical) passwords for different uses.
The approach adopted in SecourHealth requires a single password while still providing protection against offline attacks, at
least if the strong forward secrecy approach is adopted. Specifically, to determine if a guessed password is correct, the attacker

TABLE I
PROPERTIES OF KEYS PROVIDED BY SECOURHEALTH
Property
Security

Usability

Data secrecy if attackers access volatile
memory, but do not discover password
Data secrecy if attackers access volatile
memory and discover password
Prevents offline dictionary attacks if
local data are not stolen
Prevents offline dictionary attacks even
if local data are stolen
Prevents online dictionary attacks
Knowledge of password (by attacker or legitimate user) allows recovery of stored data
Allows data to be recovered without
requiring user to input password
Protected data can be sent to server at
any time, without user intervention

Kn o fs

Kw fs

Ksfs

No

Yes

Yes

No

No

Yes

Yes

Yes

Yes

No

No

Yes

No
Yes

No
Yes

No
No

Yes

No

No

Yes

Yes

Yes

would have to 1) run the registration protocol described in
Section III-B and verify if a positive assertion is received, or
2) check if the resulting MK can be used to verify the authentication tag of some locally stored, legitimate data, or to compute
Knofs . This first case is analogous to an online dictionary attack
and can be easily detected by the server, which can act accordingly. For example, the server could notify the user and limit the
rate of registration attempts with the corresponding usr for an
arbitrarily large period of time, possibly also holding as suspicious the data provided by that user until further analysis. The
second case can be performed offline, but only if there is some
locally stored data not protected by the strong forward secrecy
mechanism described in Section IIID3) or if Knofs is still in the
device’s volatile memory. In other words, since the (guessed)
master key alone cannot be used to compute any previous Ksfs ,
forms protected with this key are useless in offline attacks. In
comparison, the weak forward secrecy mechanism provides a
tradeoff between security and usability, since it allows a legitimate user to recover a form from the device’s memory (e.g., in
case it was wrongly filled) but provides less protection against
dictionary attacks. Table I summarizes this discussion, showing
the security and usability properties of each key type provided
by SecourHealth. We note that none of them are meant to prevent insider attacks, since, as further discussed in Section III-E,
legitimate users are expected to be allowed online access to data
collected in previous visits.
Fig. 4 shows the data structures employed by SecourHealth,
i.e., the keys that remain in RAM and the data structures stored in
the device’s nonvolatile (e.g., flash) memory. The dataflow of the
key generation process is summarized in Fig. 5, which shows
the actions that take place after a successful registration and
after the completion of the offline authentication. Obviously,
depending on the application’s specific requirements, only a
subset of the discussed keys need to be actually created and
used. For instance, in a scenario in which consolidated forms
are not expected to be modified, but rather replaced by new ones,
Ksfs might be used for protecting all forms to be delivered to
the server; meanwhile, Knofs could be used only for auxiliary

SIMPLICIO JR. et al.: SECOURHEALTH: A DELAY-TOLERANT SECURITY FRAMEWORK FOR MOBILE HEALTH DATA COLLECTION

767

Fig. 4. Memory organization in SecourHealth. Shaded fields indicate that the
data are encrypted.

Fig. 6. Data exchange between mobile device and server (upload and download). All requests involve a time stamp ts.

Fig. 5.

Generation and usage of SecourHealth’s keys.

processes (e.g., encrypting Ksfs ) and for encrypting partially
filled forms, but not for their authentication, since they will
never leave the mobile device. In this setting, offline dictionary
attacks would become much harder to succeed due to the lack
of locally available information for filtering wrong guesses. On
the other extreme, when modifications to consolidated forms are
frequent, it might be necessary to employ Knofs in the protection
of all forms for the sake of usability.
E. Data Exchange With Server
Fig. 6 depicts the processes employed when the mobile device
sends/retrieves data to/from the server.
As discussed in Section IIID, forms that are ready to be
handed over to the server are authenticated when placed in the
mobile device’s local memory. Therefore, they can be delivered
as soon as a communication channel is detected and without
the user’s intervention. The server will then be able to compute
the required keys for decrypting and verifying the authenticity
of the received data. This is done using information defined
upon the user’s registration (e.g., the master password) and/or
appended to the forms (e.g., the value of is when Ksfs is em-

ployed). After a form is received and verified, the server must
send a confirmation to the mobile device, which may then remove the corresponding data from its local memory. If this data
delivery process is not performed inside a secure tunnel, the
confirmation must be authenticated to prevent attackers from
sending fake upload reports to the device; it also should contain
a time stamp ts for identifying the request and avoiding replay
attacks. As depicted in Fig. 6, in SecourHealth the upload report
is protected using Knofs , allowing the device to transparently
verify its authenticity.
Some applications also involve the reception of data from
the server, such as when existing information about a family
needs to be updated. In such cases, the user must send an authenticated request to the server, which will answer according
to the corresponding user’s access rights. The basic protocol
for doing so is similar to the one employed for data delivery:
both the request and the response are accompanied by a time
stamp ts and both are protected by Knofs . Once again, this approach provides improved usability, since users do not need to
reenter their passwords for each request. On the other hand,
this also allows attackers who gain access to the device, while
a session is still active to inconspicuously download data from
the server posing as the legitimate user. This can be avoided
if, after verifying the authenticity of a request, the server issues a challenge together with the requested data: instead of
using Knofs , the server derives the key Knew from a random
nonce and the master key MK, which obliges the user to input
his/her password to decrypt the data and respond to the challenge. If the response provided is correct, the server may fall
back to the simpler process in which no challenge is issued;
on the other hand, if the server detects that a large number of
challenges are incorrectly answered (or, simply remain unanswered), it might, for example, emit an alert to the user or
manager; limit the request rate for that account; or, in an extreme case, cancel the user’s registration to that device, forcing
a new run of the registration protocol. The frequency in which
the server should issue challenges rather than directly answering to the user’s requests should be configured according to the
desired security-usability tradeoff of the target application. In

768

IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 19, NO. 2, MARCH 2015

fact, this optional mechanism might even be made unnecessary
if the application itself has some type of “lock-down” mechanism that prevents it from remaining open for too long.

E. Device Sharing
The proposed mechanisms allows legitimate users to register
from any SecourHealth-enabled device while preventing users
from accessing each other’s data in shared devices.

IV. ANALYSIS
SecourHealth was designed as a flexible solution for securing
mHealth data collection systems, including lightweight security
mechanisms that are useful in different application scenarios. In
summary, the proposed framework addresses the requirements
described in Section II as follows.
A. Tolerance to Delays and Lack of Connectivity
SecourHealth allows users to authenticate themselves in any
device in which they have previously registered and then operate in a completely offline mode if required. Even though the
registration itself requires connectivity, it must be performed
only once per device, and it could be done before the users go
to the field. After the data are collected, the forms are protected
using one of the keys described in Section D, and can be delivered to the server as soon as a communication channel becomes
available without need of a direct intervention from the user.
B. Protection Against Device Theft or Loss
SecourHealth supports data protection mechanisms with distinct security characteristics, allowing each application to adopt
the required level of security against the capture of devices by
attackers. The password itself is never left in memory, but used
to derive different keys: Knofs , Kwfs , and Ksfs . Specifically, if
only Ksfs is employed for protecting locally stored forms, attackers are unable to use them in offline dictionary attacks or to
recover their contents after somehow discovering the password;
Kwfs and Knofs are less secure in principle, but lead to better
usability as they allow users to decrypt and modify stored forms
if necessary. Finally, as discussed in Section E, SecourHealth
includes mechanisms that limit the attackers’ ability to retrieve
information from the server even after stealing a device in which
a legitimate user’s session is still active.
C. Secure Data Exchange Between Mobile Device and Server
All data exchanged between server and mobile device are encrypted and authenticated, even in the absence of an underlying
secure connection.
D. Lightweight and Low-Cost Solution
SecourHealth does not require any specific hardware and relies basically on lightweight cryptographic mechanisms, its (potentially) most expensive operation being the establishment of a
secure tunnel during registration. Moreover, the protocols employed were designed to minimize the number of messages exchanged between server and mobile device: the most common
operations (data upload/download) involve only one message
from each side of the communication, while all other operations (registration and challenge issuing) involve at most two
messages from each side.

F. Usability
SecourHealth allows users to access the system with a single
credential. Moreover, it supports many configurable securityusability tradeoffs. For example, the system can be configured to
request the user’s credential only once per session or, if desired,
once again whenever a more sensitive operations is performed
(e.g., accessing a locally stored form or downloading data from
the server). Finally, data exchange with the server can be done
without the user’s direct intervention, allowing data to be quickly
delivered whenever a communication channel is detected.
V. IMPLEMENTATION
To assess the behavior of the SecourHealth framework in
a real environment, we integrated the proposed mechanisms
into the GeoHealth system [6], an Android-based application
currently being used in the city of São Paulo as part of a governmental initiative for health data collection called “Family
Health Program.” This initiative involves teams of data collection agents responsible for assisting families in a well-defined
geographical area, surveying several primary care conditions
and promoting actions such as prevention, recovery, and rehabilitation. Partially filled forms are stored in the device’s local
memory so they can be filled later. After consolidation, the forms
are put in a first-in-first-out queue and sent as soon as possible to
the server. All collected data are georeferenced, providing health
managers with a clear view of the population’s conditions in the
surveyed regions.
The original GeoHealth architecture uses password for protecting the access to the application. More precisely, before
accessing the application, the user needs to send its password to
the server to be validated and, in case of success, the password is
stored in the mobile device’s memory. HTTPS is used for securing all communications, including the password registration and
data delivery. The data in this protected tunnel are not otherwise
encrypted or authenticated. Even though this approach does not
incur in any serious security issue for in-transit data, it leads to
some undesirable overhead due to the repeated establishment
of TLS/SSL sessions and it requires the password to remain in
memory all the time. Moreover, no security mechanism is employed for protecting the information kept in the mobile device’s
memory while no communication channel is available.
The SecourHealth-empowered GeoHealth system overcomes
these issues in the following manner.
1) User Registration: Even though the registration of a new
user still employs HTTPS, the password is not sent in
clear inside this tunnel but becomes part of the challengeresponse protocol described in Section IIIB. When compared to “plain” GeoHealth, this process adds some extra
overhead before users can use a new device. Nevertheless, since this needs to be done only once and the whole

SIMPLICIO JR. et al.: SECOURHEALTH: A DELAY-TOLERANT SECURITY FRAMEWORK FOR MOBILE HEALTH DATA COLLECTION

process is very similar to the regular password registration, this burden is not significant in practice.
2) Secure Storage: Partially filled forms are periodically
saved by the system in an automatic manner. Hence, they
are encrypted (but not authenticated) using Knofs , so they
can be repeatedly accessed by the agents. Consolidated
forms are not expected to be changed, since they are likely
to be sent to the server automatically soon after being
saved. Therefore, the system uses Ksfs for encrypting and
authenticating them. Kwfs is not used in the system and,
thus, it is not generated.
3) Data Exchange: Data exchange with the server is performed without the prior establishment of an HTTPS
channel, accelerating the delivery of consolidated forms.
Downloading data from the server normally do not involve
challenges issued by the server. The reason is that the policy adopted in GeoHealth when users request some data
are already quite strict: the server has a list of families
to be visited by each agent and usually prevents access
to information not belonging to such families. Challenge
issuing is, thus, limited to when an agent requests information about a number of families well above the average
in the same day or in exceptional cases (e.g., unplanned
emergency visits to families not assigned to the requesting
agent). Namely, for the current average of six families visited per agent per day, a challenge would be issued when
the agent requests information about the tenth family in
less than 24 h.

A. Platform Characteristics
The platform used in the resulting integrated system is the
Motorola Milestone 2, a reasonably high-end mobile device
equipped with a 1-GHz processor, 8-GiB internal flash memory, 512 MiB of RAM, 3G connection, and a 5-MP camera. The
implementation was done in Java using the Android Software
Development Kit, which provides a set of application programming interface (API) libraries to build and test Android applications. The cryptographic algorithms employed were all taken
from Spongy Castle (http://rtyley.github.io/spongycastle/), an
Android repack of the Bouncy Castle Java cryptography API
(http://www.bouncycastle.org/java.html).
Communications with the server are performed using a 3G
connection with a nominal speed of 300 kbps.

B. Cryptographic Algorithms Adopted
The cryptographic algorithms used in the implementation are
the following. We adopt PBKDF2 [18] as KDF for computing
the master key from the password, using adequate parameters
so that the total derivation time remains around 1 s. The underlying hash algorithm for PBKDF2 and other processes is SHA256 [25]. Message authentication is performed using HMACSHA256 [26], while authenticated encryption is performed with
EAX [27]. The underlying block cipher for all algorithms is the
advanced encryption standard [28].

Fig. 7.

769

User authentication and start screen.

TABLE II
BENCHMARK OF THE REGISTRATION PROCESS
N.

Operation

1.a
1.b
2
5.a
5.b
6.a
6.b
9

salt = r an dom
MK = KD F (salt  pw d)
Auth. request: (u sr, salt)
−1
seed = E M
K (challen g e)
K 0 = H (seed  MK )
r esp = MA C K 0 (‘u ser ok ’...)
Send to server: r esp
Check MA C K 0 (‘ser v ok ’...)

Avg. (ms)
3.1 ± 0.8
1012.1 ± 12.9
3266.3 ± 748.8
173.8 ± 37.7
22.0 ± 5.1
58.9 ± 15.2
1552.7 ± 413.1
47.0 ± 11.0

Comment

3600 hashes
3G (good)

3G (good)

C. Pilot Application
Fig. 7 shows some screenshots of the client application’s
authentication process, which is the same for both registration
(i.e., first-time usage) and any ensuing offline authentications.
If this process is successful, the user does not need to re-enter
his/her password until the application is closed, unless the server
issues a challenge as previously discussed.
After the data are collected, the corresponding forms are
stored in the mobile phone’s internal memory, in XML format. Partially filled forms are encrypted with Knofs . Forms that
are completely filled and ready to be sent are authenticated and
encrypted with the current value of Ksfs and stored in a buffer.
Whenever the buffer is not empty, the application periodically
searches for 3G connectivity until all forms are successfully
delivered and erased from the buffer.
D. Benchmark Results
Table II presents the benchmarks for the user registration protocol at the client side, following the same enumeration used in
Fig. 2. Each result obtained corresponds to the average of 20
executions of the same operation. In step 1.b of the registration
protocol, the generation of MK was designed to take 1 s of processing time, which led to 3600 iterative applications of the hash
function. For operations that involve data communication—
namely, steps 2 and 6—failures due to signal losses were ignored
aiming to allow the evaluation of the overhead introduced by the
cryptographic algorithms only. In addition, aiming to minimize
such failures, the tests were performed in a metropolitan area of
São Paulo with good 3G coverage/availability.

770

IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 19, NO. 2, MARCH 2015

TABLE III
BENCHMARK OF THE SECURE STORAGE MECHANISMS EMPLOYED
IN SECOURHEALTH
Operation

Derive K s f s
Authenticated-encryption
Store result in SDCard

Form (∼ 3 KB)
processing (ms)

Photo (∼ 150 KB)
processing (ms)

1.3 ± −0.3
45.0 ± 27.3
6.04 ± 0.4

1.3 ± −0.3
3125.0 ± 274.7
117.8 ± 11.1

From Table II, we can evaluate the overhead introduced by
HTTPS by comparing the costs of step 2, which includes the establishment of a TLS/SSL tunnel, and step 6.b, which does not.
The result is that this overhead ranges from approximately 0.5 to
2.9 s. Even though this overhead is low in practice, repeating the
same experiments in a scenario with a weak 3G signal reveals
that the number of connection failures due to time-out when one
attempts to establish an HTTPS connection before sending data
are considerably higher than what is obtained when the data
are sent without the establishment of a secure tunnel. Namely,
our experiments showed that an HTTPS connection fails around
20% more often than an HTTP connection in such limited connectivity scenarios. Even though this is unlike to be a critical
issue, such observation confirms the interest of avoiding the repeated establishment of HTTPS tunnels for data delivery to the
server, which are completely unnecessary in the data delivery
mechanisms of the SecourHealth framework.
We also evaluated the time consumed by the secure storage mechanisms employed by SecourHealth, namely: the authenticated encryption of data, local storage of the result, and
derivation of a new Ksfs after its usage. Table III shows the
benchmarks for two types of data: a typical form (≈3 KB) and
a photo (≈150 KB). This table shows that the Ksfs derivation
does not introduce a significant burden to the whole process.
The authenticated-encryption mechanism, on the other hand,
imposes a considerable cost for the storage of reasonably large
files. However, since it can be performed in the background, it
should not be noticeable by the user.
VI. RELATED WORK
There are in the literature many frameworks for enabling
generic data collection using mobile devices (for a survey, see
[7]), and that can also be used by health applications. Despite
their interest from an standardization point of view, the designs of such solutions usually provide only basic security measures, if any. For example, standards such as Open Data Kit
[29] and openXdata [30] provide support to HTTPS and session authentication by means of username and password, while
more advanced features such as secure storage and forward secrecy are not mentioned in their specifications. This reduced
concern with security is somewhat understandable, since their
design focus on helping the construction and management of
data collection solutions rather than on protecting them. However, in scenarios that handle highly security-sensitive data such
as medical information, an additional security layer becomes essential. Nonetheless, it is an unfortunate fact that strong security

measures do not appear as one of the main concerns in many
mHealth data collection solutions, such as GeoHealth [6], Epihandy [31], Borboleta [16], and Mobile Health Data Kit [7],
to cite a few recent works. Actually, in our literature review of
mobile data collection applications (both in the field of mHealth
and more general scenarios), we were unable to find any solution displaying the flexible combination of forward secrecy
levels provided by SecourHealth, or coping with all requirements discussed in Section II.
Despite not being a majority, some interesting proposals for
providing user/device authentication and data confidentiality in
the context of mHeatlh applications do exist. Many of them
focus on adding robust security mechanisms for EPR systems,
considering scenarios in which data are exchanged inside a hospital or between health facilities. Examples include [32], which
focus on allowing patients to asynchronously authorize a health
professional to access their (encrypted) EPR data, and [33],
which discusses how users could access their medical records
from their homes using the GBA. There are also proposals for
securely transferring medical information from/to the point of
care [34], applying (offline) access control policies to the patients’ data [35], and establishing authentication models suitable
for health applications [36]. Even though such solutions share
some features with the proposed SecourHealth framework, they
usually focus on EPR security issues such as access control
policies and securing in-transit data, not coping with many of
the specific requirements of data collection systems (e.g., secure
storage in scenarios with lack of connectivity).
Mechanisms for secure storage and end-to-end encryption
appear in mHealth data collection solutions such as PopData
[5]. However, one of the few thorough solutions in the literature
that focus specifically on securing the whole mHealth data collection process is the protocol proposed in [15], which, together
with the secure storage mechanism described in [37], forms an
extension of the openXdata standard. The combined solution
includes essential security features such as mutual authentication between user and server, encryption of stored data, and
secure data delivery. Important requirements such as allowing
devices to be shared and offline authentication of users are fully
taken into account. Nevertheless, forward secrecy is not among
the mechanisms provided, allowing attackers with physical access to the device to also access the stored data. Moreover, the
protocol specification from [15] includes some apparently unnecessary operations. Namely, its registration process requires
user and server to share not only a username and password, but
also a secret key Secret. This secret key is not directly used
for data encryption or mutual authentication, as could be expected, but rather employed for validating the server’s public
key upon the registration of the user in a new device. The public
key is then used for encrypting a new symmetric key every time
some data need to be downloaded from the server or uploaded
to it. This profusion of keys not only makes the protocol more
complex, but also defeats one of the main purposes of asymmetric encryption: allowing two entities to communicate securely
without the need of any preshared information. The net result
of using public key encryption in this case is that it prevents
attackers from tricking the device into communicating with the

SIMPLICIO JR. et al.: SECOURHEALTH: A DELAY-TOLERANT SECURITY FRAMEWORK FOR MOBILE HEALTH DATA COLLECTION

wrong server, at the cost of a more computationally expensive
protocol. SecourHealth not only adds forward secrecy to stored
data, but also avoids the aforesaid issues altogether by almost
removing the need for asymmetric cryptography, using sharedkey challenges for authentication whenever necessary. It also
can leverage on mechanisms for establishing secure channels already employed in some applications, which could remove any
need for especial-purpose public-key encryption protocols. Examples include the GBA [20], a very lightweight authentication
mechanism for mobile networks, and HTTPS, which is more
costly but remains widely supported and adopted by mHealth
solutions, including GeoHealth [6] and solutions based on the
OpenRosa specification [38].

VII. CONCLUSION
Security is one of the most imperative requirements for the
success of systems that deal with highly sensitive data, such
as medical information. Unfortunately, however, many existing
mHealth applications for data collection do not include security
mechanisms able to protect both the locally stored and in-transit
medical data gathered by them.
Aiming to close this gap, this work proposes SecourHealth,
a lightweight security framework designed specifically for this
class of applications. SecourHealth provides many security services for both stored and in-transit data, coping with this scenario’s typical constraints such as tolerance to lack of connectivity, the need of enabling device sharing, and transparency to
users. The set of tools offered in this manner can be integrated
into existing solutions or used in the design of more secure
mHealth data collection applications from the start. Indeed, our
experimental results when integrating SecourHealth into the
GeoHealth solution [6] show that it is possible to provide strong
security for the data while introducing minimal overhead to the
collection process.
Finally, it is worth noting that even though SecourHealth was
designed to prevent outsider rather than insider attacks (e.g.,
agents who simply copy old information into forms instead
of effectively following their visitation schedule), it can also
be used as a tool for discouraging the latter: since the proposed
solution prevents outsiders from illegally accessing or tampering
with the system’s data, it gives managers the ability to identify
misbehavior from insiders and act accordingly.

A. Future Work
As future work, we intend to address one of the main challenges faced by mHealth solutions together with security: standardization. Namely, we plan to consider the integration of the
mechanisms proposed in SecourHealth into standard frameworks for data collection, such as those following the OpenRosa specification. Another potential use of SecourHealth is as
an integrating part of other typical mHealth applications that
rely on mobile devices for exchanging data with a server. One
example is remote monitoring systems, in which a set of sensors
continuously supervise a patient’s health conditions at his/her

771

home, periodically delivering the acquired data to a server using
a mobile device as gateway.

REFERENCES
[1] R. Istepanian, E. Jovanov, and Y. Zhang, “Guest editorial introduction
to the special section on m-health: Beyond seamless mobility and global
wireless health-care connectivity,” IEEE Trans. Inf. Technol. Biomed.,
vol. 8, no. 4, pp. 405–414, Dec. 2004.
[2] S. Tachakra, X. Wang, R. Istepanian, and Y. Song, “Mobile e-health: The
unwired evolution of telemedicine,” Telemed. e-Health, vol. 9, no. 3, pp.
247–257, 2003.
[3] WHO, “mHealth: New horizons for health through mobile technologies,” Global Observatory for eHealth series, vol. 3. World Health
Org. Geneva, Switzerland, Tech. Rep., 2011. [Online]: Available:
http://www.who.int/goe/publications/goe_mhealth_web.pdf
[4] L. Iwaya, M. Gomes, M. Simplicio, T. Carvalho, C. Dominicini, R.
Sakuragui, M. Rebelo, M. Gutierrez, M. Näslund, and P. Håkansson,
“Mobile health in emerging countries: A survey of research initiatives in
Brazil,” J. Amer. Med. Inform. Assoc., vol. 82, no. 5, pp. 283–298, 2013.
[5] C. Hertzman, N. Meagher, and K. McGrail, “Privacy by design at population data BC,” J. Amer. Med. Inform. Assoc., vol. 20, no. 1, pp. 25–28,
2013.
[6] J. Sa, M. Rebelo, A. Brentani, S. Grisi, and M. Gutierrez, “GeoHealth:
A georeferenced system for health data analysis in primary care,” IEEE
Latin Amer. Trans., vol. 10, no. 1, pp. 1352–1356, Jan. 2012.
[7] D. Shao, “ A proposal of a mobile health data collection and reporting system for the developing world. ”Master’s thesis, School Technol., Malmö
Univ. Malmö, Sweden, 2012.
[8] A. Norris, R. Stockdale, and S. Sharma, “A strategic approach to mhealth,” Health Informatics J., vol. 15, no. 3, pp. 244–253, 2009.
[9] K. Patrick, W. Griswold, F. Raab, and S. Intille, “Health and the mobile
phone,” Amer. J. Preventive Med., vol. 35, pp. 177–181, 2008.
[10] A. Sunyaev, J. M. Leimeister, and H. Krcmar, “Open security issues in
german healthcare telematics,” in Proc. 3rd Int. Conf. Health Informatics,
2010, pp. 187–194.
[11] Infoway, “A ‘Conceptual’ Privacy Impact Assessment (PIA) on Canada’s
Electronic Health Record Solution (EHRS) Blueprint Version 2,” Canada
Health Infoway, Montreal, Quebec, Canada, Tech. Rep., 2008.
[12] Earth Institute. Barriers and Gaps Affecting mHealth in Low and Middle
Income Countries: A Policy White Paper. Washington, D.C.: mHealth
Alliance, 2010.
[13] W. A. Kaplan, “Can the ubiquitous power of mobile phones be used to
improve health outcomes in developing countries?” Globalization Health,
2, 9, 2006.
[14] J. G. Hodge, “Health information privacy and public health,” J. Law, Med.
Ethics, vol. 31, no. 4, pp. 663–671, 2003.
[15] F. Mancini, K. Mughal, S. Gejibo, and J. Klungsoyr, “Adding security
to mobile data collection,” in Proc. 13th IEEE Int. Conf. e-Health Netw.
Appl. Serv., 2011, pp. 86–89.
[16] R. Correia, F. Kon, and R. Kon, “Borboleta: A mobile telehealth system
for primary homecare,” in Proc. 23rd ACM Symp. Appl. Comput., 2008,
pp. 1343–1347.
[17] J. Black, Authenticated Encryption. Berlin, Germany: Springer, 2005.
[18] B. Kaliski. (2000). PKCS#5: Password-Based Cryptography Specification
Version 2.0 [Online]. Available: http://www.ietf.org/rfc/rfc2898.txt
[19] L. Almeida, E. Andrade, P. Barreto, and M. Simplicio, “Lyra: Passwordbased key derivation with tunable memory and processing costs,” J. Cryptographic Eng., pp. 1–15, 2014, to appear.
[20] 3GPP, “TS 33.220 Generic Authentication Architecture (GAA), version
6.9.0,” 3rd Generation Partnership Project, Valbonne, France, Tech. Rep.,
Jun. 2006. Available: http://www.3gpp.org/.
[21] S. Holtmanns, V. Niemi, P. Ginzboorg, P. Laitinen, and N. Asokan, Cellular Authentication for Mobile and Internet Services. New York, NY, USA:
Wiley, 2008.
[22] D. Florencio and C. Herley, “A large scale study of web password habits,”
in Proc. 16th Int. Conf. World Wide Web, 2007, pp. 657–666.
[23] J. Sunshine, S. Egelman, H. Almuhimedi, N. Atri, and L. F. Cranor,
“Crying wolf: An empirical study of SSL warning effectiveness,” in Proc.
18th Conf. USENIX Security Symp., 2009, pp. 399–416.
[24] J. Engler, C. Karlof, E. Shi, and D. Song, “PAKE-based web authentication: The good, the bad and the hurdles,” in Proc. IEEE Web 2.0 Security
Privacy Workshop, 2009, pp. 1–9.

772

IEEE JOURNAL OF BIOMEDICAL AND HEALTH INFORMATICS, VOL. 19, NO. 2, MARCH 2015

[25] NIST. (2012, Mar.). Federal Information Processing Standard (FIPS 1804) Secure Hash Standard, Nat. Inst. Standards Technol., Gaithersburg,
MD, USA [Online]: Available: csrc.nist.gov/publications/fips/fips1804/fips-180-4.pdf
[26] Federal Information Processing Standard (FIPS PUB 198-1) The KeyedHash Message Authentication Code, Nat. Inst. Standards Technol., Jul.
2008.
[27] M. Bellare, P. Rogaway, and D. Wagner, “The EAX mode of operation:
A two-pass authenticated-encryption scheme optimized for simplicity and
efficiency,” in Proc. Fast Softw. Encryption, 2004, pp. 389–407.
[28] NIST, Federal Information Processing Standard (FIPS 197) Advanced
Encryption Standard (AES), Nat. Inst. Standards Technol., Gaithersburg,
MD, USA, Nov. 2001.
[29] Y. Anokwa, C. Hartung, W. Brunette, G. Borriello, and A. Lerer. (2009,
May), Open source data collection in the developing world. Comput. [Online]. 42(10), pp. 97–99. Available: see also: www.http://opendatakit.org/
[30] OpenXdata, openXdata consortium (accessed on May 6, 2014).[Online].
Available: http://www.openxdata.org/
[31] P. A. Bagyenda, D. Kayiwa, C. Tumwebaze, N. Frank, and M. Mark, “A
mobile data collection tool Epihandy,” Special Topics Comput. ICT Res.,
vol. 5, pp. 327–332, 2009.
[32] T. Hupperich, H. Löhr, A.-R. Sadeghi, and M. Winandy, “Flexible patientcontrolled security for electronic health records,” in Proc. SIGHIT Int.
Health Informat. Symp., 2012, pp. 727–732.

[33] M. Shanmugam, S. Thiruvengadam, A. Khurat, and I. Maglogiannis, “Enabling secure mobile access for electronic health care applications,” in
Proc. Pervasive Health Conf. Workshops, 2006, pp. 1–8.
[34] J. Mirkovic, H. Bryhni, and C. Ruland, “Secure solution for mobile access
to patient’s health care record,” in Proc. 13th IEEE Int. Conf. e-Health
Netw. Appl. Serv., 2011, pp. 296–303.
[35] J. A. Akinyele, M. W. Pagano, M. D. Green, C. U. Lehmann, Z. N.
Peterson, and A. D. Rubin, “Securing electronic medical records using
attribute-based encryption on mobile devices,” in Proc. 1st ACM Workshop
Security Privacy Smartphones Mobile Devices, 2011, pp. 75–86.
[36] U. Sax, I. Kohane, and K. D. Mandl, “Wireless technology infrastructures
for authentication of patients: PKI that rings,” J. Amer. Med. Inform.
Assoc., vol. 12, pp. 263—268, 2005.
[37] S. H. Gejibo, F. Mancini, K. A. Mughal, R. A. B. Valvik, and J. I. Klungsyr,
“Secure data storage for mobile data collection systems,” in Proc. Int. ACM
Conf. Manag. Emergent Digital EcoSystems, 2012, pp. 1–8.
[38] OpenRosa, Openrosa consortium. [Online]. Available: http://www.
dimagi.com/collaborate/openrosa/

Authors’ photographs and biographies not available at the time of publication.

