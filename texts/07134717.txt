2878

IEEE TRANSACTIONS ON BIOMEDICAL ENGINEERING, VOL. 62, NO. 12, DECEMBER 2015

Bufferless Compression of Asynchronously Sampled
ECG Signals in Cubic Hermitian Vector Space
T. Marisaâˆ— , T. Niederhauser, A. Haeberlin, R. A. Wildhaber, R. Vogel, M. Jacomet, and J. Goette

Abstractâ€”Asynchronous level crossing sampling analog-todigital converters (ADCs) are known to be more energy efficient
and produce fewer samples than their equidistantly sampling counterparts. However, as the required threshold voltage is lowered, the
number of samples and, in turn, the data rate and the energy consumed by the overall system increases. In this paper, we present
a cubic Hermitian vector-based technique for online compression
of asynchronously sampled electrocardiogram signals. The proposed method is computationally efficient data compression. The
algorithm has complexity O(n), thus well suited for asynchronous
ADCs. Our algorithm requires no data buffering, maintaining the
energy advantage of asynchronous ADCs. The proposed method of
compression has a compression ratio of up to 90% with achievable
percentage root-mean-square difference ratios as a low as 0.97.
The algorithm preserves the superior feature-to-feature timing accuracy of asynchronously sampled signals. These advantages are
achieved in a computationally efficient manner since algorithm
boundary parameters for the signals are extracted a priori.
Index Termsâ€”Asynchronous sampling, buffer-less compression,
cubic Hermitian basis.

I. INTRODUCTION
SYNCHRONOUS analog-to-digital converters (ADCs) in
electrocardiogram (ECG) signal acquisition reduce power
and mean sampling rate as compared to constant sampling rate
ADCs [1], [2].1 Asynchronous ADCs attain these advantages
by offering signal-dependent sampling, which avoids capturing
samples when there is low-to-no-signal activity. However, as
the required threshold voltage is lowered, the number of samples and, in turn, the energy consumed by the overall system

A

Manuscript received January 3, 2015; revised June 12, 2015; accepted June
16, 2015. Date of publication June 25, 2015; date of current version November
20, 2015. This work was supported in part by the Commission for Technology and Innovation CTI (10717.1-PFLS-LS), Switzerland. Asterisk indicates
corresponding author.
âˆ— T. Marisa is with the Institute for Human Centered Engineeringâ€”microLab,
Department of Engineering and Information Technology, Bern University of
Applied Sciences, CH 2501 Biel, Switzerland, and also with the ARTORG
Center for Biomedical Engineering Research, University of Bern, 3012 Bern,
Switzerland (e-mail: thanks.marisa@bfh.ch).
T. Niederhauser is with the Institute for Human Centered Engineeringâ€”
microLab, Department of Engineering and Information Technology, Bern University of Applied Sciences, and also with the ARTORG Center for Biomedical
Engineering Research, University of Bern.
A. Haeberlin is with the ARTORG Center for Biomedical Engineering Research, University of Bern, and also with the Department of Cardiology, Inselspital, Bern University Hospital.
R. A. Wildhaber, M. Jacomet, and J. Goette are with the Institute for Human
Centered Engineeringâ€”microLab, Department of Engineering and Information
Technology, Bern University of Applied Sciences.
R. Vogel was with the University of Bern. He is now with the Department of
Cardiology, BuÌˆrgerspital Solothurn.
Color versions of one or more of the figures in this paper are available online
at http://ieeexplore.ieee.org.
Digital Object Identifier 10.1109/TBME.2015.2449901
1 Note that in asynchronous ADC, there is no sampling rate since the samples
are not equidistant.

increases [3]. There have been attempts to reduce the amount
of data generated by these asynchronous ADCs. These attempts
thus far have mostly been methods that achieve data reduction
by varying the level crossing threshold voltage during flat and
steep signal slopes [4], [5]. These methods are directly coupled
to a particular ADC design and, thus, offer power advantages.
The idea with these methods is to increase the threshold voltage
of the ADC when the signal is changing, thus reduce number
of samples in these areas. These attempts have shown great potential. However, the direct coupling of these methods with the
ADC architecture means that the methods are hardware architecture specific. Furthermore, the strategy can easily present itself
as a limitation in situations where the most interesting signal
features are in these areas of high-signal activity, because there
all the interesting features will be acquired with lower quality
than the less important portions of the signal.
We propose a portable compression methodology for asynchronous sampling that attempts to solve this dilemma. Our
efforts in developing our compression methodology have not
been in isolation. There have indeed been several others. These
developments have seen different kinds of methods; these can be
broadly classified into direct and transformation data compression methods [6]. Examples of direct methods are in [6]â€“[12].
Examples of transformation compression methods are in [8],
[13]â€“[22]. The algorithms in both classes offer different advantages. Direct methods are typically lightweight with a lower
computational burden than the transform methods [7], [9], [11].
Transform methods, on the other hand, offer better compression
ratios (CRs) and reconstructed signal quality [20]. However,
most of the developments in both direct and transform-based
methods have targeted synchronous equidistant sampling. Our
compression algorithm targets asynchronously sampled signals.
The proposed method may be classified as a transformation
compression method. The proposed approach shares a common
attribute with compressed sensing [23]: even though compressed
sensing approaches can be considered as transformation-based
approaches, compressed sensing is not computationally intensive for compression since compressed sensing systems are designed to incoherently sample data in a sparse transform domain.
All the computational intensive work is carried out during reconstruction. In our approach, compression is carried out by acquiring the signal in cubic Hermitian vector space, without any
computationally intensive transformation task, as in wavelets or
other transformation methods [18], [20], [24]. This advantage
results since the major step in the transformation is done by
the level crossing ADC. However, unlike compressed sensing,
we do not rely on incoherent sampling; indeed, level crossing
ADCs are signal dependent. Furthermore, since we capture the
signal in cubic Hermitian vector domain and reconstruct using

0018-9294 Â© 2015 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See http://www.ieee.org/publications standards/publications/rights/index.html for more information.

MARISA et al.: BUFFERLESS COMPRESSION OF ASYNCHRONOUSLY SAMPLED ECG SIGNALS IN CUBIC HERMITIAN VECTOR SPACE

Fig. 1.

2879

Level crossing sampling.

cubic Hermitian interpolation, the reconstruction is less computationally intensive than in compressed sensing. The method is
highly suited for asynchronous signal acquisition systems since:
1) The algorithmâ€™s complexity is O(n) and compresses the
samples as they arrive from the asynchronous ADC maintaining the signal activity dependence advantage. Therefore, the algorithm also does not require signal buffering
memory. This is shown by the algorithm in Section IV.
2) The inputs to the algorithm are time change information and signal events that are directly generated by the
asynchronous ADC. This is discussed in more detail in
Section II.
3) A cubic Hermitian vector is a 4-D vector with two position and two derivative axis, and both these axis pairs
are simply obtained from the asynchronous ADC output.
This is discussed in Section III.
4) Using the cubic Hermitian basis for compression means
that we also have efficient reconstruction methods available [25]â€“[27].
In this paper, we explain the development of the compression
method. In Section II, we analyze level crossing ADC sampled
data that are generated from simulations based on all the data
records in the MIT-BIH arrhythmia database [28]. Section III
discusses the relationship between asynchronously sampled data
and cubic Hermitian basis data transformation and representation. In Section IV, we present a Monteâ€“Carlo simulation model,
which we used to extract system parameters. Section V presents
the performance analysis and hardware verification. We draw
conclusions in Section VI.

Fig. 2.

Timer values probability density.

Fig. 3.

Timer difference values probability density.

II. ASYNCHRONOUSLY SAMPLED DATA ANALYSIS
Level crossing ADCs asynchronously transform signals into
high accurate time information [1], [2]. Fig. 1 shows an illustration of asynchronous sampling: the Î”T s are the change in time
between two level crossing events, and Tdiï¬€ ,i is the difference
between two consecutive Î”T s.
A. Data Analysis
The aim of our data analysis is to investigate the statistical
characteristics of asynchronously sampled data. Based on the
analysis, we develop a compression algorithm that exploits the
data characteristics. The data are generated by asynchronously

resampling all the signals from the MIT-BIH arrhythmia
database. The asynchronous ADC has a 10-bit timer. We performed resampling for Î”V resolutions of 4.0, 5.0, 6.0, and 7.0
bits per millivolt.2 The selected resolution range is common for
asynchronous ADCs [2], [3], [29], [30].
Figs. 2 and 3 show the probability density (mass) functions
of the timer values and differences, respectively.
Fig. 2 shows the distribution of the timer values for four
different levels of Î”V . The plot also shows two peaks; the
2 The

full range of the signals in the MIT-BIH database is Â±10 mV.

2880

IEEE TRANSACTIONS ON BIOMEDICAL ENGINEERING, VOL. 62, NO. 12, DECEMBER 2015

approximated in cubic Hermitian basis domain by
fËœ(t) = w0 Ï†00 (t) + w1 Ï†01 (t) + w2 Ï†10 (t) + w3 Ï†11 (t)
Fig. 4. System block diagram. AS is the level crossing asynchronous ADC
and HC is the Hermitian coder.

first and larger peak accounts for most of the samples. Thus,
most of the samples are small timer values. The second peak
is at timer count 1023, which is the overflow value for our 10bit timer. Fig. 3 shows the distribution of the timer difference
values for consecutive samples in the sequence. The plot shows
the timer differences for four different levels of Î”V . The plot
has one peak in the neighborhood of timer value zero. This
shows that most of the differences between consecutive samples
are also small. Small timer values and small differences in timer
values tell us that within the observed time and Î”V scales, there
is a smooth transition in the signalâ€™s amplitude and their first
derivative with low values for first and second derivatives. With
the information gathered this far, we move toward our goal of
designing a computationally efficient compression method with
minimal data buffering.
III. SIGNAL TRANSFORMATION AND REPRESENTATION
Our goal is to efficiently reduce the amount of data captured while ensuring that the important diagnostic information
contained in the signal is maintained. The level crossing ADC
captures the changes in time Î”T it takes for the signal to make
a predefined change Î”V . These values can be used to infer the
first derivative within the Î”T time interval as follows:
dVin /dt â‰ˆ Î”V /Î”T .

(1)

Since Î”V is fixed, and our intention is not to have an accurate
value of the point derivative but just an estimate over a short
time period for inference purposes, we may use Î”T to infer the
derivative. Fig. 4 gives the block diagram showing the essentials of our algorithm in the shaded area. Our algorithm is the
HC block. The algorithm converts and encodes acquired time
and event information into more compact cubic Hermitian basis
representation. Evi and Î”Ti are the event type (up or down
crossing), and timer value information generated
by the level
Evi , and Îº
crossing asynchronous ADC, AS block. Î”To ,
initial
Î”T value
describe our Hermitian segment. Î”To is the

of the Hermitian represented signal section, Evi is the accumulated event count, and Îº is the accumulative effect of higher
derivatives in the time interval. The algorithm can be pictorially represented by a projection part, which converts the signal
events into the cubic Hermitian basis representation, the thresholding part, which compacts the vectors, and the encoding part,
which packs the data for storage or transmission.
A. Cubic Hermitian Representation
The cubic Hermitian basis H(t) = {Ï†h (t)} is made up of
four orthogonal functions. A polynomial (segment) f (t) can be

(2)

where wi are components of the Hermitian geometry vector associated with the function f (t). The subscripts on the Hermitian
basis functions have been specifically chosen to represent the orthogonality property of the functions; orthogonality is important
since it offers computational simplicity and efficiency [31]. We
can extract the geometry vector from a monotonic segment of
f (t) as follows: with no loss of generality, we can normalize the
time internal of f (t) to t âˆˆ [0, 1], we have at the left end of f (t),

f (0) = P0 and f (0) = T0 , and for the right end f (1) = P1

and f (1) = T1 ; here, P0 and P1 are the amplitudes, and T0
and T1 are the derivatives at these ends. (P0 , P1 , T0 , T1 ) is the
Hermitian geometry vector which we have extracted from the
function f (t). The cubic Hermitian basis polynomials in vector
form are
â›
â â› 3
â
(2t âˆ’ 3t2 + 1)
Ï†00 (t)
âœ
âŸ âœ
âŸ
âœ Ï† (t) âŸ âœ (âˆ’2t3 + 3t2 ) âŸ
âœ 01 âŸ âœ
âŸ
âŸ=âœ
âŸ=
âœ
(3)
âœ
âŸ âœ 3
âŸ Ë† Ï†(t) .
âœ Ï†10 (t) âŸ âœ (t âˆ’ 2t2 + t) âŸ
â  â
â 
â
Ï†11 (t)
(t3 âˆ’ t2 )
We can represent an approximation of f (t) as fËœ(t) based on its
associated geometry vector as
fËœ(t) = (P0 , P1 , T0 , T1 ) Ï†(t).

(4)

If we generalize our time interval to t âˆˆ [to , tn ], then the instantaneous error for this approximation is given by


|f (t) âˆ’ fËœ(t)| =

f (c)
(t âˆ’ to )(t âˆ’ to )(t âˆ’ tn )(t âˆ’ tn )
384

(5)

where c âˆˆ [to , tn ]. This formula is important since it tells us
that the error can be regulated by relating the fourth derivative

(f (c)) to the interval length. The error can be kept small if we
keep [to , tn ] small. The error is zero on t = to and t = tn . The
error bounds are given by


||f ||âˆ 4
d
||f (t) âˆ’ fËœ(t)|| 
384

(6)

where d = tn âˆ’ to , and the norm is the infinity norm [32].
Having laid down the basics of cubic Hermitian vector representation, we now connect this to the data coming out of the
asynchronous ADC and show how the data are handled and
assembled by our algorithm into Hermitian geometry vectors.
B. Time to Geometry Vector
Our algorithm constructs Hermitian geometry vectors from
data generated by the asynchronous ADC. Equation (4) shows
how a signal segment is represented in cubic Hermitian vector
space by geometry vector (P0 , P1 , T0 , T1 ). In cubic Hermitian
space, the signal is split into segments and each of these segments is represented by a 4-D Hermitian vector. Fig. 5 shows
a function/signal segment f , which can be represented in the

MARISA et al.: BUFFERLESS COMPRESSION OF ASYNCHRONOUSLY SAMPLED ECG SIGNALS IN CUBIC HERMITIAN VECTOR SPACE

2881

where P0 is the left-end amplitude of the previous interpolation piece. If we let P0 = mÎ”V , where m is the cumulative
count of level crossing events up to the current interpolation
segment, and restrict interpolation segments to derivatives of
the same sign, to meet monotonicity requirements, we restrict
interpolation segments to derivatives of the same sign; then, (11)
simplifies to
Fig. 5.

fËœ(t) = Î”V (mÏ†00 (t) + (m Â± (n + 1)) Ï†01 (t)


Ï†10 (t) Ï†11 (t)
+
+
.
Î”T0
Î”Tn

Hermitian representation.

Hermitian basis as
fËœ(t) = f (to )Ï†00 (t) + f (tn )Ï†01 (t)
	
	




Î”V
Î”V
+
Ï†10 (t) +
Ï†11 (t) .
Î”To
Î”Tn

(7)

In Fig. 5, Vtot = (n + 1)Î”V , an integer multiple of Î”V , and
Ttot is a time interval composed of the sum of all Î”T s from
the asynchronous ADC during the interval. Since we know that
Î”V is fixed, we can represent the two tangent-based coordinates
using only the values of Î”T0 and Î”Tn . The function f has points
whose coordinates (ti , f (ti )) can be represented by
f (tn ) =

n


Evi âˆ— Î”V ,

with tn =

i=0

n


Î”Ti .

(8)

i=0

Here, we let the event-type operator Evi have values
{âˆ’1, 0, +1}, where âˆ’1 represents a signal decreasing event,
0 represents a timer overflow event, and +1 represents a signal
increasing event. The simplest events to handle for our algorithm are the timer overflow events. Timer overflows are merely
time-keeping events; thus, we can add the timer overflows to the
Î”T of the next signal increase or decrease event in the series of
events without introducing any error in the signal representation.
This operation turns Evi in (8) into a sign operator with values
{âˆ’1, +1}. Since Î”V is fixed and known for the asynchronous
ADC, we can determine amplitude values f (tn ) by simple event
counts as shown in (9). Since Evi is a sign operator, we can fully
represent the signal with a series of Î”Ti s with a single bit for
event type (sign):
f (tn ) = Î”V

n


Evi .

(9)

i=0

If we replace the tangent axis with asynchronous ADC generated
data, (4) becomes
fËœ(t) =

1


Pi Ï†0i (t) +

i=0

1

Î”V
Ï†1i (t) .
Î”T
i
i=0

(10)

By expressing P0 and P1 in terms of function values according
to (9), we obtain


n

Evi
fËœ(t) = Ï†00 (t)P0 + Ï†01 (t) P0 + Î”V
	
+ Î”V

i=0

Ev0
Evn
Ï†10 (t)
+ Ï†11 (t)
Î”T0
Î”Tn




(12)

Since the event type Ev is a sign operator, we have the Â± in
(12). The Hermitian geometry vector is given by


	
1
1
,
.
(13)
m, (m Â± (n + 1)),
Î”T0 Î”Tn
We do not yet have information on the time interval length.
Therefore, we introduce the variable Îº defined as
Îº=

n


(Î”Ti âˆ’ Î”To ) .

(14)

i=1

The time interval is determined as
Ttot = (n + 1)Î”To + Îº .

(15)

We have thus far shown how a signal segment can be represented
by a Hermitian geometry vector, and also how the geometry
vector can be represented by the variables n, Î”To , Î”Tn , and Îº.
IV. ALGORITHM DESIGN AND IMPLEMENTATION
We built a data compressor that maintains the activitydependent low-energy advantages of asynchronous sampling
systems. Such an algorithm should:
1) have low working memory requirements. This keeps static
energy requirements low.
2) have an order of performance at most linear O(n). This
ensures that the compression algorithm can be driven by
the signal events from the asynchronous ADC [33].
A. Modeling and Parameter Estimation
To achieve the above requirements, our algorithm must be
adaptive. It dynamically makes decisions on the error level by
observing data generated by the asynchronous ADC and use
the information to infer boundary conditions for Hermitian geometry vector construction. The error bound can be found by
evaluating (6). However, calculation of reliable values of the

infinity norm of the fourth-order derivative, ||f ||âˆ , given the
nonuniform sampling grid, is computationally intensive [34],
and we may not have enough data points for the calculation during periods of low signal activity. To overcome these challenges,
we developed an error inference method that does not rely on
the evaluation of (6).
In Fig. 5, Ttot is the Hermitian geometry vector time interval,
Ttot = tn âˆ’ to = d; with (6) and (15), this gives


(11)

||f (t) âˆ’ fËœ(t)|| 

||f ||âˆ
(nÎ”To + Îº)4 .
384

(16)

2882

IEEE TRANSACTIONS ON BIOMEDICAL ENGINEERING, VOL. 62, NO. 12, DECEMBER 2015

Equation (16) shows us that for a function f (t) in the interval
t âˆˆ [to , tn ], we can estimate the relative change in the error
bounds of cubic Hermitian vector representation by observing

the variables n, Î”To , and Îº, since ||f ||âˆ is a constant in the
interval [to , tn ]. Furthermore, since we know that at t = to and
t = tn , the instantaneous error is zero according to (5), we can
control the error in the interval t âˆˆ [to , tn ] by tracking n, Î”To ,
and Îº throughout the interval. Therefore, we need to define
the parameters for decision making and their boundaries. Our
findings in Section II guide us in developing a decision making
strategy. Figs. 2 and 3 give the following.
1) Most of the timer values generated are small. This suggests
that most of our samples are generated in a burst.
2) The time differences between consecutive events are
small, meaning that most of our signal segments have
small second derivatives.
3) There is a smooth transition from low to high timer values
and their associated differences. This means that we can
break the timer value space into zones and be guaranteed
of a smooth transition between the zones.
4) These findings are more pronounced on lower Î”V values
and are consistent on all the simulated levels.
From the exploratory data analysis and signal transformation
equations, we need to develop a strategy for packing the related
sample values into geometry vectors. We introduce another variable Ï„ that defines the Î”T values allowed within a Hermitian
geometry vector. The variable Ï„ appears as
Îº=

n


(Î”Ti âˆ’ Î”To )

for all |Î”Ti âˆ’ Î”To | < Ï„.

(17)

i=1

The variable Ï„ prohibits sudden large jumps in Î”T values. In
order to simplify the implementation, we let Ï„ , Îº, and n have
dyadic boundaries. The boundaries of Ï„ span the timer bit-width
B. For example, if we let the Qth boundary of Ï„ be Ï„Q , then
Qth boundary of Ï„ be Ï„Q , then
Ï„Q = Ï„1 Â· 2Q âˆ’1 ,

max Ï„Q < 2B

(18)

where Ï„1 is the first Ï„ boundary. For each Ï„ boundary, there are
corresponding boundaries for Îº and n, ÎºQ and Î·Q , respectively:
ÎºQ = Îº1 Â· 2Q âˆ’1 ,

max ÎºQ < 2B +1

(19)

where Îº1 is the first Îº boundary
Î·Q = Î·1 Â· 2âˆ’(Q âˆ’1) ,

Î·Q > 0

(20)

with Î·1 being the first Î· boundary.
We use a Monteâ€“Carlo simulation to find the boundaries
of our compression-steering parameters from large amounts of
data. We executed 1000 Monteâ€“Carlo runs while sweeping the
system variables Ï„ , Îº, and n. Monteâ€“Carlo simulations require
a large pool of ECG signals with characteristics covering a
wide range. To generate these signals, we use ECGSYN [35].
For ECGSYN to be useful for our Monteâ€“Carlo simulations, we
need to have underling distributions for its parameters that cover
a wide range of heart rate variations and noise conditions. Our
Monteâ€“Carlo model generates the parameters for ECGSYN by

TABLE I
ECGSYN SIGNAL-SYNTHESIZER PARAMETERSâˆ—
ECGSYN Parameter

Source/Value

Resolution
Sample rate (f e c g ) [Hz]
Heart rate mean (h m e a n ) [beats/min]
Low-frequency RSA (f L ) [Hz]
High-frequency RSA (f H ) [Hz]
Amplitude of additive uniform noise (A )

Floating point
2 000 000
Weibull
Uniform
Uniform
Gaussian

*
The high sampling frequency of 2 MHz is used to emulate an analog signal that is asynchronously sampled by an
asynchronous ADC model.

sampling the distributions shown in Table I. In Table I, RSA
means Respiratory Sinus Arrhythmia.
For various heart rate variations, our Monteâ€“Carlo simulation
samples an inverse function based on a Weibull distribution,
which is nonzero only for nonnegative values [36]. According
to [36], the parameter settings cover ECG signals for pediatrics,
young adults, and the elderly. It also covers effects of signal
phenomena such as RSA [36]. The low-frequency fL and highfrequency fH for RSA are sampled from a uniform distribution
with values in (0.04â€“0.15 Hz) and (0.15â€“0.4 Hz) for low- and
high-frequency bands, respectively. These variables also model
artifacts like baseline wander. The noise level is sampled from
a Gaussian distribution with zero mean and 0.1-mV standard
deviation.
We present Monteâ€“Carlo simulation results for two widely
used performance metrics, namely the percentage root-meansquare difference (PRD) [6], and CR, with relation to our system
variables, Î”V in bits/mV, log2 (Ï„ ), log2 (Îº), and log2 (Î·).3 Interpretation of the PRD measure from a medical point of view
has already been discussed in [37]. The CR is defined as
bitrateO âˆ’ bitrateC
Ã— 100
(21)
bitrateO
where bitrateO and bitrateC represent the number of bits
required for the original and compressed signals, respectively.
For this paper, unless stated otherwise, the value of bitrateO is
taken from the bit rate used in the MIT-BIH arrhythmia database,
calculated based on a sample rate of 360 Hz by 11 bits per sample. The MIT-BIH bit-rate definition was used to facilitate comparison with other works.
Figs. 6â€“9 show the relationship of our system variables Îº,
Ï„ , and Î· with respect to PRD and compression at Î”V level
of 5 and 7 bits. The variables are simply base-2 logarithms of
the first boundaries shown as Ï„ L, ÎºL, and Î·L. As expected,
we notice that both PRD and CR levels are higher for higher
values of Îº. We show that there is an improvement in PRD and a
reduction in CR when the Î”V resolution is increased. However,
the decrease in the CR rate shown for the high resolution may be
misleading since the CR rate with reference to the data coming
out of the asynchronous ADC is higher than the one presented
CR =

3 The timer frequency variable has weak influence on performance for timer
frequency values greater than 6 kHz. For our experiments, timer frequency is at
16 kHz.

MARISA et al.: BUFFERLESS COMPRESSION OF ASYNCHRONOUSLY SAMPLED ECG SIGNALS IN CUBIC HERMITIAN VECTOR SPACE

Fig. 6.

Signal PRD versus log2 (Ï„ ) for each value of Î”V level.

Fig. 7.

Signal compression versus log2 (Ï„ ) for each value of Î”V level.

here, which is calculated with reference to the original classical
data to enable readers to compare with other works. We also see
that at Î”V resolution of 5 bits, the event count boundary Î·L
has less effect on the PRD than Î”V resolution of 7 bits. This is
because event counts are low at this low Î”V resolution; thus,
event count boundaries are not breached. We see that the PRD
has a higher variance for high values of ÎºL and Î·L. This is
because high values of ÎºL and Î·L mean that we are reducing
the rate of response of our algorithm to changes in the incoming

Fig. 8.

Signal compression versus log2 (Ï„ ) for each value of Î”V level.

Fig. 9.

Signal compression versus log2 (Ï„ ) for each value of Î”V level.

2883

samples, thereby allowing larger variances in our performance
metrics. Furthermore, higher values of ÎºL allow larger deviation
of subsequent values of Î”T from the initial value. From the
figures, we are able to choose boundary values for our algorithm
and use these boundaries in the implementation.
B. Implementation
The algorithm adaptively constructs cubic Hermitian geometry vectors from a sequence of time intervals and events. The
adaptive construction of compact cubic Hermitian geometry

2884

IEEE TRANSACTIONS ON BIOMEDICAL ENGINEERING, VOL. 62, NO. 12, DECEMBER 2015

vectors reduces the data, while ensuring that the error remains
sufficiently small. This operation is used to assimilate samples
of little significance (those with little to no new information on
the signal) as determined by the initial timer value Î”To , segment
event counter n, zone parameter Ï„ , and accumulative effect of
higher derivatives in the time interval parameter Îº. If the rate of
new information is low, the algorithm combines the incoming
vector with the existing one by addition. It then checks Îº. If Îº
is below the threshold, the algorithm continues to construct the
Hermitian geometry vector from the events and Î”T s as they are
generated by the asynchronous ADC. This means that for rising/falling slopes in the signal, where asynchronous ADCs generate a burst of samples, but where changes per sample are small,
each consecutive sample contains redundant information when
viewed from the Hermitan basis perspective as in (12). Hence,
most of the events and Î”T s generated will be compressed into
one Hermitian geometry vector. All we have to store or transmit
is the Î”To , n, and Îº. Here is the resulting compression algorithm, which uses two auxiliary functions, StoreHV() and
CheckBoundaries(), and which we name AsyncHermitian:
StoreHV(Î”T0 , Î”Ti , Ev0 , Evi , n, Îºi )
if n == 0 then
store(Î”T0 , Ev0 )
else
store(T0 , Ev0 , n, Îºi )
Î”T0 â† Î”Ti , Ev0 â† Evi , n â† 0, Îºi â† 0
CheckBoundaries(Î”T0 , Î”Ti , Ev0 , Evi , n, Îºi )
get Q from Î”T0

if (Evi = Ev0 ) or (Î”Ti âˆ’ Î”T0 ) âˆˆ
/ [Ï„Q âˆ’1 , Ï„Q ) or
(Îºi â‰¥ ÎºQ ) or (n â‰¥ Î·Q ) then
StoreHV(Î”T0 , Î”Ti , Ev0 , Evi , n, Îºi )
else
n â† n + 1, Ev0 â† Evi , Îºi â† Îºi + (Î”Ti âˆ’ Î”T0 )
AsyncHermitian
n â† 0, Îºi â† 0, Ti â† 0
while true do
wait until (Î”V event or Î”Ti timer overflow)4 do
capture asynchronous ADC values: (Î”Ti , Evi )
if n = 0 then
Î”T0 â† Î”Ti , Ev0 â† Evi , Îºi â† 0
CheckBoundaries(Î”T0 , Ti , Ev0 , Evi , n, Îºi )
The presented algorithm has been programmed in software in
procedural form for simulations and implemented in two forms,
asynchronous and synchronous logic, on field-programmable
gate array (FPGA) hardware. Since the maximum event rate
is sufficiently low for ECG signals [3], there is no need for
parallelization on the signal processing level in our hardware
implementation.
C. Encoding
In order to ensure buffer-less compression suitable for asynchronous ADCs, we developed a simple method of packing
4 For

timer overflow, the captured value from the ADC is Î”T i = 0.

Fig. 10.

Test-bench layout algorithm evaluation.

Fig. 11.
signal.

Compressed samples and asynchronous ADC samples for an ECG

the bits for storage or transmission. Our algorithm gives out
four types of data chunks; thus, we use 2 bits to represent the
data chunk-type: increment (01), decrement (10), timer overflow
(11), compact vector (00). For example, an increasing signal geometry vector would be represented by a code 01 followed by
the Î”To , then the n, and then Îº. Since the n value does not fill
the full bit width, we do not need extra bits for the 00 code.
An uncompressed increment event that did not fit any geometry vector would simply be represented by a 01 followed by
the Î”Ti ; value and overflow values are simply represented by
11 followed by the count of overflows since these also occur
in bursts in regions of low activity. Huffman encoding or other
methods can still be used on top of the simple encoding proposed to gain additional compression at the expense of needing
buffering memory and Huffman tree storage memory.
V. RESULTS
We evaluated our algorithm based on all the signals in MITBIH arrhythmia database. We also did an FPGA-based implementation of our algorithm. We tested the implementation with
a real ECG signal acquired with an asynchronous ADC application specific integrated circuit ASIC. Fig. 10 shows the layout
of our test bench for using the MIT-BIH arrhythmia database. In
the signal flow block diagram shown in Fig. 10, the signal from
the MIT-BIH arrhythmia database is passed through a low-pass
250-Hz filter to band-limit the signal [28]. The signal is then
resampled to 2 MHz. This step is necessary since this signal
is taken to the asynchronous ADC model that requires input

MARISA et al.: BUFFERLESS COMPRESSION OF ASYNCHRONOUSLY SAMPLED ECG SIGNALS IN CUBIC HERMITIAN VECTOR SPACE

Fig. 12.

2885

Signal reconstruction quality assessment.

signals with a very fine time axis (representative of an analog
signal).
A. Hardware Implementation
We have implemented our algorithm on 500k gates Xilinx Spartan3E FPGA. We implemented the algorithm in two
unbuffered forms: a synchronous version clocked at 32 kHz
(32 768 Hz), and an asynchronous version fully driven by the
events from the asynchronous ADC. For both implementations,
the time measurement resolution is 1/32 768 s. For practical
reasons, we chose the above 32-kHz clock for running the synchronous implementation of the algorithm to match the time
measurement resolution. We tested the implementation with
an asynchronous ADC ASIC. The Î”V resolution of the asynchronous ADC is 5 bits/mV. The test signal was an ECG signal
band limited to 250 Hz. The number of sample events from the
asynchronous ADC doubles with every 1 bit increase in Î”V
[3]. Therefore, to keep the synchronous implementation of the
algorithm working, the clock rate should be doubled with every
1-bit resolution increase of the asynchronous ADC.
In terms of compression and signal quality, both the synchronous (clocked) and asynchronous versions are identical.
However, the asynchronous implementation is 30% more efficient in hardware-resource resource usage and also offers the
advantage of not requiring a clock that has to be set based on the
input signal and the Î”V . Fig. 11 shows the performance of our
algorithm on a real ECG signal captured with an asynchronous
ADC and then compressed by our algorithm. The top plot in

the figure shows the compressed samples, with Î”V resolution
of 5 bits/mV, Ï„ L = 6, Î·L = 5, and ÎºL = 5, reconstructed signal, and error signal with resulting performance of PRD = 2.6
and CR = 79. The bottom plot in the figure shows the asynchronously sampled signal with no compression.
B. Discussion
Figs. 6â€“9 show that our algorithm is robust and can be used
at different threshold resolutions. In Fig. 9, we notice that the
CR is negative for low values of the first Ï„ boundary. This is
because the asynchronous ADC generates a higher number of
samples than the original equidistant sample rate on which the
compression calculations are based. However, as the Ï„ boundary is increased, the CR rate increases allowing designers to
use asynchronous sampling ADCs in applications which would
require a high Î”V resolution. These particular applications are
normally not good candidates for asynchronous sampling due
to the high amount of data generated at low Î”V values.
For asynchronous ADCs, the number of samples increases
with increasing Î”V resolution. This phenomenon is inherent in
all asynchronous ADCs. This effect is worsened when the Î”V
value approaches the noise floor. Fig. 12 shows a signal segment
from the MIT-BIH arrhythmia database showing our algorithmâ€™s
results for different Î”V resolutions. Fig. 12 shows that at a resolution of 6 bits, our asynchronous ADC is approaching the noise
floor, hence increasing the number of samples even in regions
of low activity. Most of these samples that are close to the noise
floor are not compressed by our algorithm since it thinks that

2886

IEEE TRANSACTIONS ON BIOMEDICAL ENGINEERING, VOL. 62, NO. 12, DECEMBER 2015

TABLE II
PERFORMANCE COMPARISON FOR DIFFERENT COMPRESSION METHODS
Parameter

This work

CSBL[22]

CSBP [21]

WDB10 [21]

CR%
PRD%
Memory Bytes
Additions
Multiplications

50â€“85
0.97â€“9.61
16
312â€“420
0

20â€“65
â€”#
6500*
768â€“5888
0

20â€“74
1.58â€“9.0
6500
5888*
0

75â€“86
1.1â€“7.52
4600
11 272
11 784

The # means the paper [22] gives mean square errors only. We can, however,
assume the values are close to those in [21]. The * means that the value was
derived from the related work.

these samples have valuable information. In an implementation
where there is no need for buffer-less compression, Huffman
encoding can be carried out on the Hermitian packed vectors.
Our simulations indicate that this would result in less than 10%
increase in compression.
We compare the performance results of our compression
method to wavelet compressed equidistantly sampled signals
and to compressed sensing techniques; Table II presents the
results.
Table II shows that our method required less computational
effort compared to wavelets and digital compressed sensing
approaches. The table also shows that our method also requires
much lower working memory with eight (16 bit) registers. These
are not for data buffering but rather for holding our parameters
and state bits. Our method also achieves high compression rates.
VI. CONCLUSION
We have proposed a buffer-less and noncomputationally intensive compression method for asynchronous level crossing
ADCs. Our approach offers dynamic error tracking by watching
the accumulative effect of first and higher derivatives of the signal. This ability to dynamically monitor the error level enables
our approach to offer signal compression with reconstructedsignal quality and CRs comparable to more computationally
intensive methods such as wavelets-based approaches [24]. Our
compression and performance results are compared to others in
Table II. The buffer-less operation is beneficial for asynchronous
sampling systems and allows efficient implementations. Additionally, hardware implementations would lead to low-area and
low-power implementations. We also shown that the algorithm
can operate in conditions of noise even though there is an increase in the number of samples. We went further to implement
and verify the algorithm on hardware in two configurations a
synchronous version with a low clock of 32 kHz (32 768 Hz)
and an asynchronous version which we found to be 30% more
hardware-resource efficient. For both implementations, the time
measurement resolution is 1/32 768 s.
We have presented our algorithm for the compression of ECG
signals. However, the algorithm can be used for other signals by
adapting the parameters to suit the characteristics of signal families in question. Other possible signals include accelerometer
signals and other biomedical signals such as EEGs.

REFERENCES
[1] N. Sayiner et al., â€œA level-crossing sampling scheme for A/D conversion,â€
IEEE Trans. Circuits Syst. II, Analog Digital Signal Process., vol. 43,
no. 4, pp. 335â€“339, Apr. 1996.
[2] E. Allier et al., â€œA new class of asynchronous A/D converters based on
time quantization,â€ in Proc. 9th Int. Symp. Asynchronous Circuits Syst.,
May 2003, pp. 196â€“205.
[3] Y. Li et al., â€œA sub-microwatt asynchronous level-crossing ADC for
biomedical applications,â€ IEEE Trans. Biomed. Circuits Syst., vol. 7,
no. 2, pp. 149â€“157, Apr. 2013.
[4] M. Kurchuk and Y. Tsividis, â€œSignal-dependent variable-resolution quantization for continuous-time digital signal processing,â€ in Proc. IEEE Int.
Symp. Circuits Syst., May 2009, pp. 1109â€“1112.
[5] M. Trakimas and S. Sonkusale, â€œAn adaptive resolution asynchronous
ADC architecture for data compression in energy constrained sensing
applications,â€ IEEE Trans. Circuits Syst. I, Reg. Papers, vol. 58, no. 5,
pp. 921â€“934, May 2011.
[6] S. M. Jalaleddine et al., â€œ ECG data compression techniquesâ€”A unified
approach,â€ IEEE Trans. Biomed. Eng., vol. 37, no. 4, pp. 329â€“343, Apr.
1990.
[7] J. R. Cox et al., â€œ AZTEC, a preprocessing program for real-time ECG
rhythm analysis,â€ IEEE Trans. Biomed. Eng., vol. 15, no. 2, pp. 128â€“129,
Apr. 1968.
[8] N. Ahmed et al., â€œElectrocardiographic data compression via orthogonal
transforms,â€ IEEE Trans. Biomed. Eng., vol. BME-22, no. 6, pp. 484â€“487,
Nov. 1975.
[9] W. C. Mueller, â€œArrhythmia detection program for an ambulatory ECG
monitor,â€ Biomed. Sci. Instrum., vol. 14, pp. 81â€“85, Apr. 1978.
[10] J. P. Abenstein and W. J. Tompkins, â€œA new data-reduction algorithm for
real-time ECG analysis,â€ IEEE Trans. Biomed. Eng., vol. BME-29, no. 1,
pp. 43â€“48, Jan. 1982.
[11] S. C. Tai, â€œSLOPEâ€”A real-time ECG data compressor,â€ Med. Biol. Eng.
Comput., vol. 29, no. 2, pp. 175â€“179, Mar. 1991.
[12] S. C. Tai, â€œECG data compression by corner detection,â€ Med. Biol. Eng.
Comput., vol. 30, no. 6, pp. 584â€“590, Nov. 1992.
[13] B. R. Reddy and I. S. Murthy, â€œECG data compression using fourier
descriptors,â€ IEEE Trans. Biomed. Eng., vol. 33, no. 4, pp. 428â€“434, Apr.
1986.
[14] H. A. al Nashash, â€œECG data compression using adaptive fourier coefficients estimation,â€ Med. Eng. Phys., vol. 16, no. 1, pp. 62â€“66, Jan.
1994.
[15] H. A. al Nashash, â€œA dynamic fourier series for the compression of ECG
using FFT and adaptive coefficient estimation,â€ Med. Eng. Phys., vol. 17,
no. 3, pp. 197â€“203, Apr. 1995.
[16] Z. Lu et al., â€œWavelet compression of ECG signals by the set partitioning
in hierarchical trees algorithm,â€ IEEE Trans. Biomed. Eng., vol. 47, no. 7,
pp. 849â€“856, Jul. 2000.
[17] M. Kyoso and A. Uchiyama, â€œECG data reduction method for medical
telemetry systems,â€ Frontiers Med. Biological Eng.: Int. J. Japan Soc.
Med. Electron. Biol. Eng., vol. 11, no. 2, pp. 131â€“152, 2001.
[18] S.-G. Miaou and S.-N. Chao, â€œWavelet-based lossy-to-lossless ECG compression in a unified vector quantization framework,â€ IEEE Trans. Biomed.
Eng., vol. 52, no. 3, pp. 539â€“543, Mar. 2005.
[19] G. Tohumoglu and K. E. Sezgin, â€œECG signal compression by multiiteration EZW coding for different wavelets and thresholds,â€ Comput.
Biol. Med., vol. 37, no. 2, pp. 173â€“182, Feb. 2007.
[20] H.-L. Chan et al., â€œWavelet-based ECG compression by bit-field preserving and running length encoding,â€ Comput. Methods Programs Biomed.,
vol. 90, no. 1, pp. 1â€“8, Apr. 2008.
[21] H. Mamaghanian et al., â€œCompressed sensing for real-time energyefficient ECG compression on wireless body sensor nodes,â€ IEEE Trans.
Biomed. Eng., vol. 58, no. 9, pp. 2456â€“2466, Sep. 2011.
[22] Z. Zhang et al., â€œCompressed sensing for energy-efficient wireless telemonitoring of noninvasive fetal ECG via block sparse Bayesian learning,â€ IEEE Trans. Biomed. Eng., vol. 60, no. 2, pp. 300â€“309, Feb.
2013.
[23] E. J. CandeÌ€s et al., â€œStable signal recovery from incomplete and inaccurate
measurements,â€ Commun. Pure Appl. Math., vol. 59, no. 8, pp. 1207â€“1223,
2006.
[24] J. Chen and S. Itoh, â€œA wavelet transform-based Ecg compression method
guaranteeing desired signal quality,â€ IEEE Trans. Biomed. Eng., vol. 45,
no. 12, pp. 1414â€“1419, Dec. 1998.
[25] F. N. Fritsch and R. E. Carlson, â€œMonotone piecewise cubic interpolation,â€
SIAM J. Numerical Anal., vol. 17, no. 2, pp. 238â€“246, 1980.

MARISA et al.: BUFFERLESS COMPRESSION OF ASYNCHRONOUSLY SAMPLED ECG SIGNALS IN CUBIC HERMITIAN VECTOR SPACE

[26] A. Ahmadian et al., â€œAn efficient piecewise modeling of ECG signals
based on Hermitian basis functions,â€ in Proc. 29th Annu. Int. Conf. IEEE
Eng. Med. Biol. Soc., 2007, pp. 3180â€“3183.
[27] R. Gopalikrishnan and D. H. Mugler, â€œThe evolution of Hermite transform in biomedical applications,â€ in Intelligent Medical Technologies and
Biomedical Engineering: Tools and Applications., Hershey, PA, USA: IGI
Global, 2010, pp. 260â€“278.
[28] A. L. Goldberger et al., â€œPhysioBank, PhysioToolkit, and PhysioNet:
Components of a new research resource for complex physiologic signals,â€
Circulation, vol. 101, no. 23, pp. e215â€“e220, Jun. 13, 2000.
[29] M. Trakimas and S. Sonkusale, â€œA 0.8 V asynchronous ADC for energy constrained sensing applications,â€ in Proc. IEEE Custom Integrated
Circuits Conf., Sep. 2008, pp. 173â€“176.
[30] K. Kozmin et al., â€œLevel-crossing ADC performance evaluation toward
ultrasound application,â€ IEEE Trans. Circuits Syst. I, Reg. Papers, vol. 56,
no. 8, pp. 1708â€“1719, Aug. 2009.
[31] T. Chihara, An Introduction to Orthogonal Polynomials. New York, NY,
USA: Gordon and Breach, 1978.
[32] C. Moler, Numerical Computing with MATLAB. Philadelphia, PA, USA:
SIAM, 2004.

2887

[33] Y. P. Tsividis, â€œEvent-driven data acquisition and digital signal
processingâ€”A tutorial,â€ IEEE Trans. Circuits Syst. II, Exp. Briefs,
vol. 57, no. 8, pp. 577â€“581, Aug. 2010.
[34] X. Z. Ratnesh, K. Shukla, â€œDerivation of high-order compact finite difference schemes for non-uniform grid using polynomial interpolation,â€ J.
Comput. Phys., vol. 204, no. 2, pp. 404â€“429, 2005.
[35] P. E. McSharry and G. D. Cifford, â€œOpen-source software for generating
electrocardiogram signals,â€ arXiv:physics/0406017, Jun. 2004.
[36] S. J. Mandrekar et al., â€œStatistical modelling of the differences between
successive RR intervals,â€ Statist. Med., vol. 24, no. 3, pp. 437â€“451, Feb.
2005.
[37] Y. Zigel et al., â€œThe weighted diagnostic distortion (WDD) measure for
ECG signal compression,â€ IEEE Trans. Biomed. Eng., vol. 47, no. 11,
pp. 1422â€“1430, Nov. 2000.

Authorsâ€™ photographs and biographies not available at the time of publication.

